<!doctype html>
<html lang="th">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Idle TD ‚Äî GM Edition v2.5</title>
<style>
  :root{
    --bg:#0b1220; --card:#0f172a; --line:#243041; --ink:#e2e8f0; --mut:#a8b3c7;
    --pri:#22d3ee; --ok:#22c55e; --warn:#f59e0b; --bad:#ef4444; --yel:#facc15;
    --safe:#2e7d32; --ore:#8d6e63; --bal:#2962ff; --lava:#b91c1c; --ice:#38bdf8; --sand:#ca8a04;
    --water: #0c4a6e;
    --bg-grassland:#166534; --path-grassland:#a16207;
    --bg-desert:#b45309; --path-desert:#fde68a;
    --bg-frostlands:#075985; --path-frostlands:#e0f2fe;
    --bg-volcanic:#4f46e5; --path-volcanic:#1e293b;
  }
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html,body{height:100%;margin:0}
  body{background:var(--bg);color:var(--ink);font:14px system-ui,Segoe UI,Roboto}
  .wrap{max-width:1400px;margin:0 auto;padding:12px}
  header{position:sticky;top:0;background:#0b1220cc;border-bottom:1px solid var(--line);backdrop-filter:blur(8px);z-index:10}
  .hud{display:flex;flex-wrap:wrap;gap:8px;align-items:center;justify-content:space-between;padding:8px 0}
  .pill{display:flex;align-items:center;gap:6px;background:var(--card);border:1px solid var(--line);border-radius:999px;padding:6px 10px;font-size:12px}
  .btn{cursor:pointer;border:1px solid var(--line);background:linear-gradient(180deg,#1b2636,#131b28);color:var(--ink);padding:8px 12px;border-radius:10px; transition: all 0.15s ease;}
  .btn:hover{border-color:#3b4a63; transform: translateY(-1px);}
  .btn:disabled{background:#111a2a;color:var(--mut);border-color:var(--line);cursor:not-allowed; transform: none;}
  .gridWrap{display:grid;grid-template-columns:1fr;gap:12px}
  canvas{display:block;width:100%;height:auto;border:1px solid var(--line);border-radius:12px;cursor:crosshair; background-color: #000;}
  .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:10px}
  .row{display:flex;flex-wrap:wrap;gap:8px}
  .list{
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(64px, 1fr));
    gap: 8px;
  }
  @media (min-width:1000px){.gridWrap{grid-template-columns:3fr 1fr}}
  .modal{position:fixed;inset:0;background:rgba(2,6,23,.8);backdrop-filter:blur(4px);display:flex;align-items:center;justify-content:center;z-index:100;opacity:0;visibility:hidden;transition:opacity .2s,visibility .2s}
  .modal.visible{opacity:1;visibility:visible}
  .modal-content{background:var(--card);border:1px solid var(--line);border-radius:16px;padding:14px;width:90%;max-width:500px;max-height:85vh;overflow-y:auto}
  .modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
  .tier{border:1px solid var(--line);padding:10px;border-radius:10px;margin-bottom:10px;background:#0b1220}
  .tier h4{margin:0 0 8px}
  .tier p{font-size:12px;color:var(--mut);margin:0 0 8px}
  #loadingOverlay{color:white;font-size:1.5em;text-align:center}

  /* GM Panel Styles */
  .gm-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(220px, 1fr)); gap: 10px; }
  .gm-entity-card { background: var(--bg); padding: 8px; border-radius: 8px; border: 1px solid var(--line); }
  .gm-entity-card h4 { margin:0 0 8px; font-size: 1em; display:flex; align-items:center; gap: 8px;}
  .gm-sprite-list { display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px; padding-top: 8px; border-top: 1px solid var(--line);}
  .gm-sprite-preview { width: 36px; height: 36px; border: 2px solid var(--line); border-radius: 4px; cursor: pointer; image-rendering: pixelated; background-color: #0005; background-position: center; background-repeat: no-repeat; background-size: contain; transition: all .15s ease; }
  .gm-sprite-preview:hover { transform: scale(1.1); border-color: var(--mut); }
  .gm-sprite-preview.selected { border-color: var(--pri); transform: scale(1.1); box-shadow: 0 0 8px var(--pri);}
  .gm-current-sprite { width: 24px; height: 24px; image-rendering: pixelated; background-color: #0005; border-radius: 4px; }

  /* Build Menu Icon Styles */
  .build-icon {
    position: relative;
    aspect-ratio: 1 / 1;
    background: var(--bg);
    border: 2px solid var(--line);
    border-radius: 8px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.15s ease;
    overflow: hidden;
    user-select: none;
  }
  .build-icon:hover {
    border-color: var(--pri);
    transform: translateY(-2px);
  }
  .build-icon.disabled {
    filter: grayscale(1) brightness(0.6);
    cursor: not-allowed;
    transform: none;
  }
  .build-icon.selected {
      border-color: var(--ok);
      box-shadow: 0 0 10px var(--ok);
  }
  .build-icon-sprite {
    width: 100%;
    height: 100%;
    background-repeat: no-repeat;
    background-position: center;
    image-rendering: pixelated;
    transform: scale(2.5); /* Make the 16x16 sprite bigger */
  }
  .build-icon-cost {
    position: absolute;
    bottom: 2px;
    right: 4px;
    font-size: 11px;
    font-weight: bold;
    color: var(--yel);
    text-shadow: 1px 1px 1px #000;
  }
  .build-icon.disabled .build-icon-cost {
      color: var(--mut);
  }

  /* Upgrade Panel */
  .upgrade-stats { font-size: 12px; line-height: 1.6; }
  .upgrade-stats .arrow { color: var(--pri); }
  .upgrade-stats .increase { color: var(--ok); }
  .upgrade-stats .decrease { color: var(--bad); }


</style>
</head>
<body>
<header class="wrap">
  <div class="hud">
    <div class="row">
      <div class="pill">üèõÔ∏è ‡∏ê‡∏≤‡∏ô‡∏ó‡∏±‡∏û: <b id="citadelHP">100</b>/<b id="citadelMaxHP">100</b> (Tier <b id="citadelTier">1</b>)</div>
      <div class="pill">üí∞ <b id="gold">0</b></div>
      <div class="pill">‚õèÔ∏è <b id="ore">0</b></div>
      <div class="pill">‚öôÔ∏è <b id="components">0</b></div>
      <div class="pill">üî© <b id="gears">0</b></div>
      <div class="pill">üíé <b id="cores">0</b></div>
      <div class="pill">üåä Wave <b id="wave">0</b></div>
    </div>
    <div class="row">
      <button class="btn" id="btnStart">‚ñ∂ Start Wave</button>
      <button class="btn" id="btnCitadel">üèõÔ∏è ‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏ê‡∏≤‡∏ô‡∏ó‡∏±‡∏û</button>
      <button class="btn" id="btnSpeed">‚è© Speed x1</button>
      <button class="btn" id="btnGM">üßë‚Äç‚öñÔ∏è GM Mode</button>
    </div>
  </div>
</header>

<main class="wrap gridWrap">
  <section><canvas id="game" width="1280" height="720"></canvas></section>
  <aside class="panel">
    <h3 style="margin:0 0 8px">‡∏™‡∏¥‡πà‡∏á‡∏Å‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á (Tier <span id="buildTier">1</span>)</h3>
    <div class="list" id="buildMenu"></div>
    <h3 style="margin:12px 0 8px">‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å</h3>
    <div id="selectedInfo" class="panel" style="min-height:120px;background:#0b1220;padding:8px">
      <small style="color:var(--mut)">‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏õ‡πâ‡∏≠‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î</small>
    </div>
  </aside>
</main>

<!-- Citadel Upgrade Modal -->
<div id="citadelModal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2>‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏ê‡∏≤‡∏ô‡∏ó‡∏±‡∏û</h2>
      <button id="closeCitadelModal" class="btn">√ó</button>
    </div>
    <div id="citadelTiers"></div>
  </div>
</div>

<!-- GM Panel Modal -->
<div id="gmModal" class="modal">
  <div class="modal-content" style="max-width: 90vw; width: 1200px;">
    <div class="modal-header">
      <h2>üßë‚Äç‚öñÔ∏è GM Panel</h2>
      <button id="closeGmModal" class="btn">√ó</button>
    </div>
    <h3>üé® Map Theme</h3>
    <div id="gmThemeSelector" class="row"></div>
    <hr style="border-color: var(--line); margin: 12px 0;">
    <h3>üëæ Enemy Appearance</h3>
    <div id="gmEnemySelector" class="gm-grid"></div>
    <hr style="border-color: var(--line); margin: 12px 0;">
    <h3>üóº Tower Appearance</h3>
    <div id="gmTowerSelector" class="gm-grid"></div>
  </div>
</div>


<div id="worldOverlay" class="modal visible">
  <div id="loadingOverlay" style="display:none;"><p>‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£...</p></div>
  <div id="selectionContent" class="modal-content" style="max-width:960px">
    <h3>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏±‡πâ‡∏á‡∏ê‡∏≤‡∏ô‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏•‡∏Å</h3>
    <canvas id="world" width="960" height="540" style="background-color: var(--water);"></canvas>
    <div id="zonePreview" style="margin-top:10px;min-height:40px;">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ö‡∏ô‡∏ö‡∏Å...</div>
    <button class="btn" id="btnConfirm" disabled style="width:100%;margin-top:10px">‚úÖ ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏ê‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà</button>
  </div>
</div>

<script>
(async function(){

// ===== Atlas Loader (Global) =====
const ATLAS_IMAGE_BASE64 = 'data:image/png;base64,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';

const ATLAS_JSON_DATA = {
    "frames": {
        "enemy_bat_0": { "x": 0, "y": 0, "w": 16, "h": 16 },
        "enemy_bat_1": { "x": 16, "y": 0, "w": 16, "h": 16 },
        "enemy_ghost_0": { "x": 32, "y": 0, "w": 16, "h": 16 },
        "enemy_ghost_1": { "x": 48, "y": 0, "w": 16, "h": 16 },
        "enemy_golem_0": { "x": 0, "y": 16, "w": 16, "h": 16 },
        "enemy_golem_1": { "x": 16, "y": 16, "w": 16, "h": 16 },
        "enemy_slime_0": { "x": 32, "y": 16, "w": 16, "h": 16 },
        "enemy_slime_1": { "x": 48, "y": 16, "w": 16, "h": 16 },
        "enemy_boss_0": { "x": 64, "y": 0, "w": 16, "h": 32 },

        "tower_cannon_base": { "x": 0, "y": 32, "w": 16, "h": 16 },
        "tower_cannon_turret": { "x": 0, "y": 48, "w": 16, "h": 16 },
        "tower_crystal_base": { "x": 16, "y": 32, "w": 16, "h": 16 },
        "tower_crystal_turret": { "x": 16, "y": 48, "w": 16, "h": 16 },
        "tower_dual_base": { "x": 32, "y": 32, "w": 16, "h": 16 },
        "tower_dual_turret": { "x": 32, "y": 48, "w": 16, "h": 16 },
        "tower_spike_base": { "x": 48, "y": 32, "w": 16, "h": 16 },
        "tower_spike_turret": { "x": 48, "y": 48, "w": 16, "h": 16 },
        
        "building_mine": { "x": 64, "y": 48, "w": 16, "h": 16 },
        "building_barracks": { "x": 64, "y": 32, "w": 16, "h": 16 },

        "vfx_explosion_0": { "x": 0, "y": 64, "w": 16, "h": 16 },
        "vfx_explosion_1": { "x": 16, "y": 64, "w": 16, "h": 16 },
        "vfx_explosion_2": { "x": 32, "y": 64, "w": 16, "h": 16 },
        "vfx_explosion_3": { "x": 48, "y": 64, "w": 16, "h": 16 }
    }
};
// ===== Asset Source (External, optional) =====
let ATLAS_IMAGE_URL = 'https://nongprogress.github.io/Game/assets/atlas.png';
let ATLAS_JSON_URL  = 'https://nongprogress.github.io/Game/assets/atlas.json'; // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô ''

const Atlas = { img:new Image(), frames:{}, ready:false };

function normalizeFrames(map){
  if (map.frames && !Array.isArray(map.frames)) return map.frames;
  if (Array.isArray(map.frames)) {
    const out={};
    for(const f of map.frames){
      const n=(f.filename||'').replace(/\.(png|jpe?g)$/i,'');
      const fr=f.frame||f; out[n]={x:fr.x,y:fr.y,w:fr.w,h:fr.h,pivot:f.pivot||{x:.5,y:.5}};
    }
    return out;
  }
  return {};
}

async function loadAtlas(){
  try{
    const useRemote = !!ATLAS_IMAGE_URL;

    let map = ATLAS_JSON_DATA;
    if (useRemote && ATLAS_JSON_URL) {
      const res = await fetch(ATLAS_JSON_URL, { mode:'cors' });
      map = await res.json();
    }
    Atlas.frames = normalizeFrames(map);

    Atlas.img = new Image();
    Atlas.img.crossOrigin = 'anonymous';
    await new Promise(res=>{
      Atlas.img.onload = res;
      Atlas.img.onerror = res;
      Atlas.img.src = useRemote ? ATLAS_IMAGE_URL : ATLAS_IMAGE_BASE64;
    });

    Atlas.ready = !!Atlas.img.naturalHeight;
    console.log('[Atlas] ready', { remote: useRemote, frames: Object.keys(Atlas.frames).length });
  }catch(e){
    console.warn('[Atlas] load failed', e);
    Atlas.ready = false;
  }
}

function drawFrame(ctx, name, x, y, w, h, rot=0){
  const f = Atlas.frames?.[name];
  if(!Atlas.ready || !f || !Atlas.img.complete || Atlas.img.naturalHeight === 0) return false;
  
  ctx.save(); ctx.translate(x,y); if(rot) ctx.rotate(rot);
  ctx.imageSmoothingEnabled = false;
  ctx.drawImage(Atlas.img, f.x,f.y,f.w,f.h, -w/2,-h/2, w,h);
  ctx.restore(); return true;
}
window.Atlas=Atlas; window.drawFrame=drawFrame;

// ===== Sound Engine =====
const Sound = {
    audioCtx: null,
    init() {
        if (!this.audioCtx) {
            this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
    },
    play(type, options = {}) {
        if (!this.audioCtx || this.audioCtx.state !== 'running') return;

        const now = this.audioCtx.currentTime;
        const gainNode = this.audioCtx.createGain();
        gainNode.connect(this.audioCtx.destination);
        
        if (type === 'shoot') {
            const osc = this.audioCtx.createOscillator();
            osc.connect(gainNode);
            gainNode.gain.setValueAtTime(0.3, now);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, now + options.duration);
            osc.type = options.waveType;
            osc.frequency.setValueAtTime(options.freq, now);
            osc.start(now);
            osc.stop(now + options.duration);
        } else if (type === 'hit') {
            const osc = this.audioCtx.createOscillator();
            osc.connect(gainNode);
            gainNode.gain.setValueAtTime(0.2, now);
            gainNode.gain.exponentialRampToValueAtTime(0.0001, now + 0.15);
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(100, now);
            osc.start(now);
            osc.stop(now + 0.15);
        } else if (type === 'explode') {
             const bufferSize = this.audioCtx.sampleRate * 0.5;
             const buffer = this.audioCtx.createBuffer(1, bufferSize, this.audioCtx.sampleRate);
             const data = buffer.getChannelData(0);
             for (let i = 0; i < bufferSize; i++) {
                 data[i] = Math.random() * 2 - 1;
             }
             const noise = this.audioCtx.createBufferSource();
             noise.buffer = buffer;
             
             const filter = this.audioCtx.createBiquadFilter();
             filter.type = 'lowpass';
             filter.frequency.setValueAtTime(1200, now);
             filter.frequency.exponentialRampToValueAtTime(100, now + 0.3);

             noise.connect(filter);
             filter.connect(gainNode);

             gainNode.gain.setValueAtTime(0.4, now);
             gainNode.gain.exponentialRampToValueAtTime(0.001, now + 0.4);
             
             noise.start(now);
             noise.stop(now + 0.4);
        }
    },
    playShoot(towerKey) {
        const sounds = {
            GUN: { freq: 800, duration: 0.1, waveType: 'square' },
            FROST: { freq: 600, duration: 0.2, waveType: 'sine' },
            ROCKET: { freq: 200, duration: 0.15, waveType: 'sawtooth' },
            ARTILLERY: { freq: 150, duration: 0.2, waveType: 'triangle' }
        };
        if (sounds[towerKey]) {
            this.play('shoot', sounds[towerKey]);
        }
    }
};


// === Patterns & Ground ===
function drawGround(ctx){
  const img = BgImg[state.biome];
  if (img && img.complete && img.naturalHeight>0){
    const t  = performance.now()/1000;
    const ox = Math.floor((Math.sin(t*0.10)+1)*20);
    const oy = Math.floor((Math.cos(t*0.07)+1)*20);
    ctx.drawImage(img, -ox, -oy, ctx.canvas.width+ox*2, ctx.canvas.height+oy*2);
  } else {
    const root = getComputedStyle(document.documentElement);
    const biomeBg = root.getPropertyValue(`--bg-${state.biome.toLowerCase()}`).trim();
    ctx.fillStyle = biomeBg || '#134e4a';
    ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height);
  }
}

function drawPath(ctx){
  const ts = TS();
  const wOuter = ts.w * 1.20;
  const wInner = ts.w * 0.90;
  const root = getComputedStyle(document.documentElement);
  const pathFallback = root.getPropertyValue(`--path-${state.biome.toLowerCase()}`).trim() || '#a16207';

  ctx.save();
  ctx.lineCap='round'; ctx.lineJoin='round';
  ctx.shadowColor='rgba(0,0,0,.35)'; ctx.shadowBlur=8; ctx.shadowOffsetY=2;
  ctx.strokeStyle = 'rgba(0,0,0,.25)'; ctx.lineWidth = wOuter;
  ctx.beginPath(); for(const p of state.path) ctx.lineTo(p.x, p.y); ctx.stroke();
  ctx.restore();

  ctx.save();
  ctx.lineCap='round'; ctx.lineJoin='round';
  ctx.strokeStyle = pathFallback;
  ctx.lineWidth = wInner;
  ctx.beginPath(); for(const p of state.path) ctx.lineTo(p.x, p.y); ctx.stroke();
  ctx.restore();
}

// ===== GAME CONFIG =====
// ===== Biome Backgrounds (external) =====
const BIOME_BG = {
  GRASSLAND: 'https://nongprogress.github.io/Game/assets/bg_grass.png',
  DESERT:    'https://nongprogress.github.io/Game/assets/bg_desert.png',
  FROSTLANDS:'https://nongprogress.github.io/Game/assets/bg_frost.png',
  VOLCANIC:  'https://nongprogress.github.io/Game/assets/bg_volcanic.png',
};
const BgImg = {};
function preloadBiomeBG(){
  for(const [k,url] of Object.entries(BIOME_BG)){
    const img = new Image();
    img.crossOrigin = 'anonymous';
    img.src = url;
    BgImg[k] = img;
  }
}

const CONFIG = {
  GRID:{ COLS:24, ROWS:14 },
  CITADEL_TIERS:{
    1:{ hp:100, unlocks:['GUN','MINE'] },
    2:{ hp:150, cost:{gold:100, components:5}, unlocks:['FROST','ROCKET'] },
    3:{ hp:220, cost:{gold:1200, components:20, gears:10}, unlocks:['ARTILLERY','BARRACKS'] },
    4:{ hp:350, cost:{gold:3000, gears:20, cores:5}, unlocks:['METEOR_STRIKE'] }
  },
  TOWER_TYPES:{
    GUN:{
        name:'‡∏õ‡πâ‡∏≠‡∏°‡∏õ‡∏∑‡∏ô‡∏Å‡∏•', tier:1,
        cost:{ gold:30, ore:0 },
        stats:{ dmg:35, range:2.3, rate:5.9, projectileSpeed:450 },
        maxLevel: 10,
        levelUp: {
            cost: { gold: 20 },
            costMultiplier: 1.4,
            statMultipliers: { dmg: 1.22, range: 1.04, rate: 1.02 }
        }
    },
    FROST:{
        name:'‡∏õ‡πâ‡∏≠‡∏°‡∏ô‡πâ‡∏≥‡πÅ‡∏Ç‡πá‡∏á', tier:2,
        cost:{ gold:80, ore:10 },
        stats:{ dmg:45, range:2.1, rate:1.2, slow:0.35, projectileSpeed:350 },
        maxLevel: 10,
        levelUp: {
            cost: { gold: 50, ore: 5 },
            costMultiplier: 1.5,
            statMultipliers: { dmg: 1.25, range: 1.05, slow: 1.08 }
        }
    },
    ROCKET:{
        name:'‡∏õ‡πâ‡∏≠‡∏°‡∏à‡∏£‡∏ß‡∏î', tier:2,
        cost:{ gold:120, ore:30 },
        stats:{ dmg:40, range:2.8, rate:0.4, splash:1.0, projectileSpeed:300 },
        maxLevel: 10,
        levelUp: {
            // ‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏á‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏Ç‡∏Å‡∏≤‡∏£‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î
            // ‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏û‡∏¥‡πà‡∏° 'gears: X' ‡∏´‡∏£‡∏∑‡∏≠ 'cores: Y' ‡πÄ‡∏Ç‡πâ‡∏≤‡πÑ‡∏õ‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢
            // ‡∏£‡∏∞‡∏ö‡∏ö‡∏à‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏´‡∏±‡∏Å‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Ñ‡∏∏‡∏ì‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÇ‡∏î‡∏¢‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
            cost: { gold: 80, ore: 15, components: 1 },
            costMultiplier: 1.5,
            statMultipliers: { dmg: 1.2, range: 1.03, splash: 1.1 }
        }
    },
    ARTILLERY:{
        name:'‡∏õ‡πâ‡∏≠‡∏°‡∏õ‡∏∑‡∏ô‡πÉ‡∏´‡∏ç‡πà', tier:3,
        cost:{ gold:200, ore:50 },
        stats:{ dmg:80, range:4.5, rate:0.25, splash:1.5, projectileSpeed:200 },
        maxLevel: 10,
        levelUp: {
            cost: { gold: 150, ore: 30 },
            costMultiplier: 1.6,
            statMultipliers: { dmg: 1.25, range: 1.05, splash: 1.15 }
        }
    }
  },
  BUILDING_TYPES:{
    MINE:{ name:'‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏á‡πÅ‡∏£‡πà', tier:1, cost:{gold:40,ore:0}, stats:{ rate:5, yield:2 } },
    BARRACKS:{ name:'‡∏Ñ‡πà‡∏≤‡∏¢‡∏ó‡∏´‡∏≤‡∏£', tier:3, cost:{gold:150,ore:20}, limit:1 }
  },
  ENEMY_TYPES:{
    RUNNER:{ hp:80, speed:60, reward:20, type:'normal' },
    BRUTE:{ hp:250, speed:40, reward:50, type:'elite' },
    FLYER:{ hp:100, speed:75, reward:80, type:'normal', flying:true },
    BOSS:{ hp:2000, speed:35, reward:100, type:'boss' }
  },
  WAVE_COMPOSITION:[
    {RUNNER:10},{RUNNER:15},{RUNNER:10,BRUTE:2},{RUNNER:20,FLYER:5},{BRUTE:8,FLYER:5},
    {RUNNER:25,BRUTE:5},{FLYER:15,BRUTE:5},{RUNNER:20,BRUTE:10},{BRUTE:15,FLYER:10},{BOSS:1,RUNNER:20}
  ],
  BIOME_MODIFIERS:{
    GRASSLAND:{ name:'‡∏ó‡∏∏‡πà‡∏á‡∏´‡∏ç‡πâ‡∏≤', desc:'‡∏™‡∏°‡∏î‡∏∏‡∏• ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ú‡∏•‡∏û‡∏¥‡πÄ‡∏®‡∏©', color:'var(--safe)', background:'var(--bg-grassland)', path:'var(--path-grassland)', mods:{} },
    DESERT:{ name:'‡∏ó‡∏∞‡πÄ‡∏•‡∏ó‡∏£‡∏≤‡∏¢', desc:'‡∏õ‡πâ‡∏≠‡∏°‡∏¢‡∏¥‡∏á‡∏ä‡πâ‡∏≤‡∏•‡∏á 5%, ‡∏®‡∏±‡∏ï‡∏£‡∏π HP -10%', color:'var(--sand)', background:'var(--bg-desert)', path:'var(--path-desert)', mods:{ towerRate:0.95, enemyHP:0.9 } },
    FROSTLANDS:{ name:'‡πÅ‡∏î‡∏ô‡∏ô‡πâ‡∏≥‡πÅ‡∏Ç‡πá‡∏á', desc:'Frost Tower ‡∏™‡πÇ‡∏•‡∏ß‡πå x1.2, ‡∏õ‡πâ‡∏≠‡∏° AOE Dmg -15%', color:'var(--ice)', background:'var(--bg-frostlands)', path:'var(--path-frostlands)', mods:{ frostSlow:1.2, splashDmg:0.85 } },
    VOLCANIC:{ name:'‡πÄ‡∏Ç‡∏ï‡∏†‡∏π‡πÄ‡∏Ç‡∏≤‡πÑ‡∏ü', desc:'‡∏®‡∏±‡∏ï‡∏£‡∏π‡∏ï‡πâ‡∏≤‡∏ô‡∏ó‡∏≤‡∏ô AOE, ‡∏î‡∏£‡∏≠‡∏õ‡πÅ‡∏£‡πà‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô', color:'var(--lava)', background:'var(--bg-volcanic)', path:'var(--path-volcanic)', mods:{ enemySplashResist:0.2, oreYield:1.25 } }
  },
  ENEMY_DROPS:{
    normal:{ components:0.15, gears:0.03 },
    elite:{ components:0.4, gears:0.1 },
    boss:{ components:1, gears:0.5, cores:1 }
  }
};

const state = {
  mode:'map-select', citadelTier:1, citadelHP:100,
  gold:200, ore:50, components:5, gears:0, cores:0,
  wave:0, speed:1,
  towers:[], buildings:[], enemies:[], bullets:[], effects:[], path:[], pathGrid:new Set(),
  lastTime:0, buildMode:null, selectedEntity:null,
  biome:'GRASSLAND', mouse:{x:0,y:0}, decorations:[],
  spriteMap: { // GM Sprite Selections
    RUNNER: 'enemy_slime',
    BRUTE: 'enemy_golem',
    FLYER: 'enemy_bat',
    BOSS: 'enemy_boss',
    GUN: 'tower_cannon',
    FROST: 'tower_crystal',
    ROCKET: 'tower_dual',
    ARTILLERY: 'tower_spike',
    MINE: 'building_mine',
    BARRACKS: 'building_barracks'
  }
};

const game = document.getElementById('game');
const g = game.getContext('2d');
const buildMenu = document.getElementById('buildMenu');

// ===== Core Classes =====
class Entity{ constructor(c,r){ this.c=c; this.r=r; const {x,y}=tileCenter(c,r); this.x=x; this.y=y; } center(){ return {x:this.x,y:this.y}; } update(dt){} draw(ctx){} }

class Tower extends Entity{
  constructor(c,r,key){ super(c,r); this.key=key; this.type='tower';
    this.def=CONFIG.TOWER_TYPES[key]; this.stats=JSON.parse(JSON.stringify(this.def.stats));
    this.cooldown=0; this.target=null; this.angle=0; this.level=1;
  }
  update(dt){
    this.cooldown -= dt;
    if(this.target && (!this.target.alive || dist(this.x,this.y,this.target.x,this.target.y) > this.stats.range*TS().w)){ this.target=null; }
    if(!this.target) this.findTarget();
    if(this.target){ this.angle = Math.atan2(this.target.y - this.y, this.target.x - this.x); if(this.cooldown<=0) this.shoot(); }
  }
  findTarget(){
    let best=null, maxProg=-1;
    for(const e of state.enemies){
      if(e.def.flying && this.key==='ROCKET') continue;
      const d=dist(this.x,this.y,e.x,e.y);
      if(d <= this.stats.range*TS().w && e.pathProgress>maxProg){ best=e; maxProg=e.pathProgress; }
    }
    this.target = best;
  }
  shoot(){
    const rateMod = CONFIG.BIOME_MODIFIERS[state.biome].mods.towerRate || 1;
    this.cooldown = 1 / (this.stats.rate * rateMod);
    state.bullets.push(new Bullet(this.x, this.y, this.target, this));
    Sound.playShoot(this.key);
  }
  draw(ctx){
    const size = TS().w * 1.1;
    const spriteStem = state.spriteMap[this.key] || `tower_cannon`;
    const baseName   = `${spriteStem}_base`;
    const turretName = `${spriteStem}_turret`;

    // Base
    if (!drawFrame(ctx, baseName, this.x, this.y, size, size)) {
        ctx.fillStyle = '#475569';
        ctx.beginPath();
        ctx.arc(this.x, this.y, size * 0.4, 0, Math.PI * 2);
        ctx.fill();
    }
    
    // Turret (rotated)
    ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle);
    ctx.shadowColor='rgba(0,0,0,.35)'; ctx.shadowBlur=8; ctx.shadowOffsetY=4;
    if (!drawFrame(ctx, turretName, 0, 0, size, size)) {
        ctx.fillStyle = '#22d3ee';
        ctx.fillRect(-size / 8, -size / 8, size / 4, size / 2);
    }
    ctx.restore();

    if(state.selectedEntity===this){
      ctx.save(); ctx.globalAlpha=.2; ctx.fillStyle='#fff'; ctx.beginPath();
      ctx.arc(this.x,this.y,this.stats.range*TS().w,0,Math.PI*2); ctx.fill(); ctx.restore();
    }
  }
}

class Building extends Entity{
  constructor(c,r,key){ super(c,r); this.key=key; this.type='building'; this.def=CONFIG.BUILDING_TYPES[key]; this.timer=0; }
  update(dt){
    if(this.key==='MINE'){
      this.timer += dt;
      if(this.timer >= this.def.stats.rate){
        this.timer = 0;
        const oreMod = CONFIG.BIOME_MODIFIERS[state.biome].mods.oreYield || 1;
        state.ore += this.def.stats.yield * oreMod;
        state.effects.push(new FloatingText(`+${Math.round(this.def.stats.yield*oreMod)} Ore`, this.x, this.y));
      }
    }
  }
  draw(ctx){
    const size = TS().w * 1.1;
    const spriteName = state.spriteMap[this.key] || `building_${this.key.toLowerCase()}`;
    if(!drawFrame(ctx, spriteName, this.x, this.y, size, size)){
       const ts=TS(); ctx.fillStyle='#94a3b8'; ctx.fillRect(this.x-ts.w/2+4, this.y-ts.h/2+4, ts.w-8, ts.h-8);
       ctx.fillStyle='#facc15'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font='24px sans-serif'; ctx.fillText(this.key==='MINE'?'‚õèÔ∏è':'üèõÔ∏è', this.x, this.y);
    }
  }
}

class Enemy{
  constructor(key){
    this.key=key; this.def=CONFIG.ENEMY_TYPES[key];
    const startPos=state.path[0]; this.x=startPos.x; this.y=startPos.y;
    this.pathIndex=0; this.pathProgress=0;
    const hpMod = CONFIG.BIOME_MODIFIERS[state.biome].mods.enemyHP || 1;
    this.maxHp = Math.floor(this.def.hp * (1 + state.wave * 0.1) * hpMod);
    this.hp=this.maxHp; this.alive=true; this.slowTimer=0; this.slowFactor=1;
    this.animT=0;
  }
  update(dt){
    this.animT += dt;
    if(this.slowTimer>0) this.slowTimer -= dt; else this.slowFactor=1;
    const target = state.path[this.pathIndex+1];
    if(!target){ this.alive=false; state.citadelHP--; if(state.citadelHP<=0) toast("‡∏ê‡∏≤‡∏ô‡∏ó‡∏±‡∏û‡∏ñ‡∏π‡∏Å‡∏ó‡∏≥‡∏•‡∏≤‡∏¢!"); return; }
    const angle=Math.atan2(target.y - this.y, target.x - this.x);
    const speed=this.def.speed * this.slowFactor * dt;
    this.x += Math.cos(angle)*speed; this.y += Math.sin(angle)*speed;
    this.pathProgress += speed; if(dist(this.x,this.y,target.x,target.y)<5) this.pathIndex++;
  }
  takeDamage(dmg, splashResistMod=0){
    const finalDmg = dmg * (1 - splashResistMod);
    this.hp -= finalDmg;
    Sound.play('hit');
    if(this.hp<=0 && this.alive){
      this.alive=false; state.gold += this.def.reward;
      const drop = CONFIG.ENEMY_DROPS[this.def.type];
      if(drop){ for(const [item,ch] of Object.entries(drop)){ if(Math.random()<ch){ state[item]++; state.effects.push(new FloatingText(`+1 ${item}`, this.x, this.y-20)); updateHUD(); } } }
    }
  }
  draw(ctx){
    const size = this.key==='BOSS'? TS().w * 1.5 : TS().w;
    const spriteStem = state.spriteMap[this.key] || `enemy_slime`;
    
    const fi = Math.floor(this.animT * 5) % 2; // Simple 2-frame animation
    const frameName = `${spriteStem}_${fi}`;
    
    let ok = drawFrame(ctx, frameName, this.x, this.y, size, size);
    if (!ok) {
        ok = drawFrame(ctx, spriteStem + '_0', this.x, this.y, size, size); // Fallback to frame 0
    }
    if(!ok) {
        ctx.save(); ctx.translate(this.x,this.y);
        ctx.shadowColor='rgba(0,0,0,.25)'; ctx.shadowBlur=6; ctx.shadowOffsetY=3;
        if(this.key==='RUNNER'){ ctx.fillStyle='#ef4444'; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill(); }
        if(this.key==='BRUTE'){ ctx.fillStyle='#a855f7'; ctx.fillRect(-10,-10,20,20); }
        if(this.key==='FLYER'){ ctx.fillStyle='#eab308'; ctx.beginPath(); ctx.moveTo(0,-10);ctx.lineTo(10,10);ctx.lineTo(-10,10);ctx.closePath();ctx.fill(); }
        if(this.key==='BOSS'){ ctx.fillStyle='#dc2626'; ctx.beginPath(); ctx.arc(0,0,16,0,Math.PI*2); ctx.fill(); }
        ctx.restore();
    }

    if(this.slowTimer>0){ ctx.strokeStyle='#38bdf8'; ctx.lineWidth=2; ctx.globalAlpha=.7; ctx.beginPath(); ctx.arc(this.x,this.y,size/2.5,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1; }
    const barY=this.y-size/2-5; ctx.fillStyle='#1e293b'; ctx.fillRect(this.x-15,barY,30,4); ctx.fillStyle='#16a34a'; ctx.fillRect(this.x-15,barY,30*(this.hp/this.maxHp),4);
  }
}

class Bullet{
  constructor(x,y,target,tower){ this.x=x; this.y=y; this.target=target; this.tower=tower; this.alive=true; }
  update(dt){
    if(!this.target.alive){ this.alive=false; return; }
    const angle=Math.atan2(this.target.y-this.y, this.target.x-this.x);
    const speed=this.tower.stats.projectileSpeed*dt; this.x+=Math.cos(angle)*speed; this.y+=Math.sin(angle)*speed;
    if(dist(this.x,this.y,this.target.x,this.target.y)<10) this.hit();
  }
  hit(){
    this.alive=false;
    const splashMod = CONFIG.BIOME_MODIFIERS[state.biome].mods.splashDmg || 1;
    const splashRes = CONFIG.BIOME_MODIFIERS[state.biome].mods.enemySplashResist || 0;
    if(this.tower.stats.splash>0){
      Sound.play('explode');
      state.effects.push(new Explosion(this.target.x,this.target.y,this.tower.stats.splash*TS().w));
      state.enemies.forEach(e=>{ if(dist(this.target.x,this.target.y,e.x,e.y) < this.tower.stats.splash*TS().w){ e.takeDamage(this.tower.stats.dmg*splashMod, splashRes); } });
    }else{
      this.target.takeDamage(this.tower.stats.dmg);
    }
    if(this.tower.stats.slow>0){ const slowMod = CONFIG.BIOME_MODIFIERS[state.biome].mods.frostSlow || 1; this.target.slowFactor = 1 - (this.tower.stats.slow*slowMod); this.target.slowTimer = 2; }
  }
  draw(ctx){
    if(this.tower.key==='GUN') ctx.fillStyle='#67e8f9';
    else if(this.tower.key==='FROST') ctx.fillStyle='#7dd3fc';
    else if(this.tower.key==='ROCKET') ctx.fillStyle='#fb923c';
    else ctx.fillStyle='#94a3b8';
    ctx.beginPath(); ctx.arc(this.x,this.y,4,0,Math.PI*2); ctx.fill();
  }
}

class Effect{ constructor(x,y){ this.x=x; this.y=y; this.alive=true; this.life=1; } update(dt){ this.life-=dt; if(this.life<=0) this.alive=false; } draw(ctx){} }
class Explosion extends Effect{
  constructor(x,y,radius){ super(x,y); this.radius=radius; this.life=0.4; }
  draw(ctx){
    const p = 1 - (this.life/0.4);
    const fi = Math.min(3, Math.floor(p*4));
    if(!drawFrame(ctx, `vfx_explosion_${fi}`, this.x, this.y, this.radius*2, this.radius*2)){
      ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * p, 0, Math.PI*2);
      ctx.fillStyle = `rgba(251,146,60,${1-p})`; ctx.fill();
    }
  }
}
class FloatingText extends Effect{
  constructor(text,x,y){ super(x,y); this.text=text; this.life=1.2; }
  update(dt){ super.update(dt); this.y -= 20*dt; }
  draw(ctx){ ctx.font='bold 12px Segoe UI'; ctx.fillStyle=`rgba(250,250,250,${this.life/1.2})`; ctx.textAlign='center'; ctx.fillText(this.text,this.x,this.y); }
}

// ===== Logic =====
function initGame(){
  resize(); window.addEventListener('resize',resize);
  game.addEventListener('mousemove', e=>{ const r=game.getBoundingClientRect(); state.mouse.x=e.clientX-r.left; state.mouse.y=e.clientY-r.top; });
  game.addEventListener('click', handleCanvasClick);
  window.addEventListener('keydown', e=>{ if(e.key==='Escape'){ if(state.buildMode){ state.buildMode=null; toast('‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á'); updateBuildMenu(); } else if(state.selectedEntity){ state.selectedEntity=null; updateSelectedInfo(); toast('‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å'); } }});
  buildPath(); updateCitadelUI(); updateBuildMenu();
  state.citadelHP = CONFIG.CITADEL_TIERS[state.citadelTier].hp;
  updateHUD();
  generateDecorations(); loop(0);
}
function generateDecorations(){ /* Decorations disabled for clarity */ state.decorations = []; }
function startWave(){
  if(state.enemies.length>0) return toast("‡∏Å‡∏≥‡∏à‡∏±‡∏î‡∏®‡∏±‡∏ï‡∏£‡∏π‡πÉ‡∏´‡πâ‡∏´‡∏°‡∏î‡∏Å‡πà‡∏≠‡∏ô");
  state.wave++;
  const waveData = CONFIG.WAVE_COMPOSITION[(state.wave-1)%CONFIG.WAVE_COMPOSITION.length];
  let spawnQueue=[]; for(const [k,c] of Object.entries(waveData)){ for(let i=0;i<c;i++) spawnQueue.push(k); }
  const spawnInterval = setInterval(()=>{ if(spawnQueue.length>0){ state.enemies.push(new Enemy(spawnQueue.shift())); } else { clearInterval(spawnInterval); } }, 800/state.speed);
}
function handleCanvasClick(){
  const {c,r} = worldToTile(state.mouse.x, state.mouse.y);
  if(c<0||r<0||c>=CONFIG.GRID.COLS||r>=CONFIG.GRID.ROWS) return;

  if(state.buildMode){
    if (isTooCloseToPath(c,r)) return toast('‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ');
    placeEntity(c,r);
  } else {
    const hit=[...state.towers,...state.buildings].find(e=>e.c===c && e.r===r);
    state.selectedEntity=hit||null;
    updateSelectedInfo();
  }
}
function placeEntity(c,r){
  if(state.pathGrid.has(`${c},${r}`)) return toast("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ö‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏ô‡πÑ‡∏î‡πâ");
  if(isTooCloseToPath(c,r))             return toast('‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ');
  if([...state.towers,...state.buildings].some(e=>e.c===c && e.r===r)) return toast("‡∏°‡∏µ‡∏™‡∏¥‡πà‡∏á‡∏Å‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß");

  const key=state.buildMode, isTower=!!CONFIG.TOWER_TYPES[key];
  const def=isTower?CONFIG.TOWER_TYPES[key]:CONFIG.BUILDING_TYPES[key];

  if(state.gold>=def.cost.gold && state.ore>=(def.cost.ore||0)){
    state.gold-=def.cost.gold; state.ore-=(def.cost.ore||0);
    if(isTower) state.towers.push(new Tower(c,r,key)); else state.buildings.push(new Building(c,r,key));
    state.buildMode=null; 
    updateHUD();
    updateBuildMenu();
  }else toast('‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡πÑ‡∏°‡πà‡∏û‡∏≠');
}
function loop(ts){ if(!state.lastTime) state.lastTime=ts; const dt=Math.min(0.05,(ts-state.lastTime)/1000); state.lastTime=ts; const u=dt*state.speed; update(u); draw(); requestAnimationFrame(loop); }
function update(dt){ if(state.mode!=='play') return; state.towers.forEach(t=>t.update(dt)); state.buildings.forEach(b=>b.update(dt));
  state.bullets=state.bullets.filter(b=>b.alive); state.bullets.forEach(b=>b.update(dt));
  state.enemies=state.enemies.filter(e=>e.alive); state.enemies.forEach(e=>e.update(dt));
  state.effects=state.effects.filter(e=>e.alive); state.effects.forEach(e=>e.update(dt)); updateHUD();
}
function draw(){
  g.clearRect(0,0,game.width, game.height);
  drawGround(g);
  drawPath(g);

  state.buildings.forEach(e=>e.draw(g));
  state.towers.forEach(e=>e.draw(g));
  state.enemies.forEach(e=>e.draw(g));
  state.bullets.forEach(e=>e.draw(g));
  state.effects.forEach(e=>e.draw(g));

  drawBuildOverlay(g);
}

function updateHUD(){ const tier=CONFIG.CITADEL_TIERS[state.citadelTier];
  document.getElementById('citadelHP').textContent=state.citadelHP;
  document.getElementById('citadelMaxHP').textContent=tier.hp;
  document.getElementById('citadelTier').textContent=state.citadelTier;
  document.getElementById('gold').textContent=Math.floor(state.gold);
  document.getElementById('ore').textContent=Math.floor(state.ore);
  document.getElementById('components').textContent=Math.floor(state.components);
  document.getElementById('gears').textContent=Math.floor(state.gears);
  document.getElementById('cores').textContent=Math.floor(state.cores);
  document.getElementById('wave').textContent=state.wave;
}
function updateBuildMenu(){
    buildMenu.innerHTML = '';
    document.getElementById('buildTier').textContent = state.citadelTier;

    const allBuildings = { ...CONFIG.TOWER_TYPES, ...CONFIG.BUILDING_TYPES };

    for (const [key, data] of Object.entries(allBuildings)) {
        const isUnlocked = data.tier <= state.citadelTier;

        const iconContainer = document.createElement('div');
        iconContainer.className = 'build-icon';
        if (!isUnlocked) {
            iconContainer.classList.add('disabled');
        }
        iconContainer.title = `${data.name}\nCost: ${data.cost.gold} Gold\nRequires Tier: ${data.tier}`;

        const spriteDiv = document.createElement('div');
        spriteDiv.className = 'build-icon-sprite';
        const spriteKey = state.spriteMap[key];
        const frameName = CONFIG.TOWER_TYPES[key] ? `${spriteKey}_base` : spriteKey;
        const f = Atlas.frames[frameName];
        if (f && Atlas.img.complete && Atlas.img.naturalHeight !== 0) {
            spriteDiv.style.backgroundImage = `url(${Atlas.img.src})`;
            spriteDiv.style.backgroundPosition = `-${f.x}px -${f.y}px`;
        }
        iconContainer.appendChild(spriteDiv);
        
        const costDiv = document.createElement('div');
        costDiv.className = 'build-icon-cost';
        costDiv.textContent = data.cost.gold;
        iconContainer.appendChild(costDiv);

        iconContainer.onclick = () => {
            if (isUnlocked) {
                if (state.buildMode === key) {
                    state.buildMode = null;
                    toast('‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á');
                } else {
                    state.buildMode = key;
                    state.selectedEntity = null;
                    updateSelectedInfo();
                }
                updateBuildMenu(); 
            } else {
                toast(`‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏ê‡∏≤‡∏ô‡∏ó‡∏±‡∏û‡πÄ‡∏õ‡πá‡∏ô Tier ${data.tier} ‡∏Å‡πà‡∏≠‡∏ô`);
            }
        };
        
        if (state.buildMode === key) {
            iconContainer.classList.add('selected');
        }

        buildMenu.appendChild(iconContainer);
    }
}
function updateSelectedInfo(){
    const box = document.getElementById('selectedInfo');
    const t = state.selectedEntity;
    if(!t || t.type!=='tower'){ box.innerHTML = `<small style="color:var(--mut)">‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏õ‡πâ‡∏≠‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î</small>`; return; }

    const def = t.def;
    const levelUpDef = def.levelUp;
    const isMaxLevel = t.level >= def.maxLevel;

    let statsHtml = `<b>${def.name}</b><br>Level: ${t.level} / ${def.maxLevel}<br><div class="upgrade-stats">`;

    // Calculate and format current stats
    const formatStat = (val, key) => {
        if (key === 'slow') return `${(val * 100).toFixed(0)}%`;
        if (key === 'rate') return val.toFixed(2);
        if (Number.isInteger(val)) return val;
        return val.toFixed(1);
    }

    Object.entries(t.stats).forEach(([key, val]) => {
        if (key === 'projectileSpeed') return;
        statsHtml += `<span>${key.toUpperCase()}: ${formatStat(val, key)}</span>`;

        // Preview next level stats
        if (!isMaxLevel && levelUpDef.statMultipliers[key]) {
            const nextVal = val * levelUpDef.statMultipliers[key];
            statsHtml += ` <span class="arrow">‚Üí</span> <span class="increase">${formatStat(nextVal, key)}</span>`;
        }
        statsHtml += `<br>`;
    });
    statsHtml += '</div>';

    let buttonHtml = '';
    if (isMaxLevel) {
        buttonHtml = `<button class="btn" disabled>‚≠ê MAX LEVEL ‚≠ê</button>`;
    } else {
        const cost = getTowerLevelUpCost(t);
        const costHtml = Object.entries(cost).map(([k,v])=>`${v} ${k}`).join(', ');
        buttonHtml = `<button id="levelUpBtn" class="btn" style="width:100%">Level Up (${costHtml})</button>`;
    }

    box.innerHTML = `
        <div style="display:flex;flex-direction:column;gap:8px">
            ${statsHtml}
            ${buttonHtml}
        </div>`;

    if (!isMaxLevel) {
        document.getElementById('levelUpBtn').onclick = () => attemptLevelUpTower(t);
    }
}

function getTowerLevelUpCost(tower){
    const def = tower.def.levelUp;
    const nextLevel = tower.level; // cost for level n+1 is calculated at level n
    const finalCost = {};
    for(const [resource, baseCost] of Object.entries(def.cost)){
        finalCost[resource] = Math.floor(baseCost * Math.pow(def.costMultiplier, nextLevel - 1));
    }
    return finalCost;
}

function attemptLevelUpTower(tower){
    const def = tower.def;
    if(tower.level >= def.maxLevel) return toast("Max level reached");

    const cost = getTowerLevelUpCost(tower);
    const canAfford = Object.entries(cost).every(([k, v]) => state[k] >= v);

    if(!canAfford) return toast("‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡πÑ‡∏°‡πà‡∏û‡∏≠");

    Object.entries(cost).forEach(([k, v]) => state[k] -= v);

    tower.level++;
    for(const [stat, multiplier] of Object.entries(def.levelUp.statMultipliers)){
        if(tower.stats[stat] !== undefined){
            tower.stats[stat] *= multiplier;
        }
    }
    
    toast(`${tower.def.name} ‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡πÄ‡∏õ‡πá‡∏ô Level ${tower.level}!`);
    updateHUD();
    updateSelectedInfo();
}

function updateCitadelUI(){
  const container=document.getElementById('citadelTiers'); container.innerHTML='';
  for(let i=2;i<=4;i++){ const tier=CONFIG.CITADEL_TIERS[i]; const div=document.createElement('div'); div.className='tier';
    const costHtml=Object.entries(tier.cost||{}).map(([k,v])=>`${v} ${k}`).join(', ')||'‚Äî';
    const unlocksHtml=(tier.unlocks||[]).map(k=>CONFIG.TOWER_TYPES[k]?.name||CONFIG.BUILDING_TYPES[k]?.name||k).join(', ');
    div.innerHTML=`<h4>Tier ${i}</h4><p>‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ: ${unlocksHtml}</p><button id="upgradeTier${i}" class="btn">‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î (${costHtml})</button>`;
    container.appendChild(div);
    const btn=document.getElementById(`upgradeTier${i}`);
    if(state.citadelTier>=i){ btn.textContent='‚úÖ ‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡πÅ‡∏•‡πâ‡∏ß'; btn.disabled=true; }
    else if(state.citadelTier!==i-1){ btn.textContent='‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î Tier ‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤'; btn.disabled=true; }
    else{ btn.onclick=()=>upgradeCitadel(); }
  }
}
function upgradeCitadel(){
  const next=state.citadelTier+1; if(!CONFIG.CITADEL_TIERS[next]) return;
  const cost=CONFIG.CITADEL_TIERS[next].cost||{}; const ok=Object.entries(cost).every(([k,v])=>state[k]>=v);
  if(ok){ Object.entries(cost).forEach(([k,v])=>state[k]-=v); state.citadelTier=next; const t=CONFIG.CITADEL_TIERS[next]; state.citadelHP=t.hp; toast(`‡∏ê‡∏≤‡∏ô‡∏ó‡∏±‡∏û‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡πÄ‡∏õ‡πá‡∏ô Tier ${next}!`); updateHUD(); updateCitadelUI(); updateBuildMenu(); }
  else toast('‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡πÑ‡∏°‡πà‡∏û‡∏≠');
}

// ===== GM Panel Logic =====
function openGmPanel() {
    // ‡πÉ‡∏ï‡πâ‡∏™‡πà‡∏ß‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á Theme Selector ‡πÉ‡∏ô openGmPanel()
    const btnAtlas = document.createElement('button');
    btnAtlas.className = 'btn';
    btnAtlas.textContent = 'üì¶ Load External Atlas';
    btnAtlas.onclick = async () => {
      const imgUrl  = prompt('Atlas PNG URL (CORS-enabled):', ATLAS_IMAGE_URL || '');
      const jsonUrl = prompt('Atlas JSON URL (optional):', ATLAS_JSON_URL || '');
      if (imgUrl) {
        ATLAS_IMAGE_URL = imgUrl;
        ATLAS_JSON_URL  = jsonUrl || '';
        await loadAtlas();
        updateBuildMenu();
        openGmPanel();
        toast('Atlas reloaded');
      }
    };
    // ‡πÅ‡∏ó‡∏£‡∏Å‡∏õ‡∏∏‡πà‡∏°‡πÑ‡∏ß‡πâ‡πÉ‡∏ï‡πâ‡πÅ‡∏ñ‡∏ß‡∏ò‡∏µ‡∏°
    const themeContainer = document.getElementById('gmThemeSelector');
    themeContainer.parentNode.insertBefore(btnAtlas, themeContainer.nextSibling);

    Object.entries(CONFIG.BIOME_MODIFIERS).forEach(([key, biome]) => {
        const btn = document.createElement('button');
        btn.className = 'btn';
        btn.textContent = biome.name;
        btn.style.backgroundColor = state.biome === key ? 'var(--pri)' : '';
        btn.onclick = () => {
            state.biome = key;
            toast(`‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ò‡∏µ‡∏°‡πÄ‡∏õ‡πá‡∏ô ${biome.name}`);
            openGmPanel(); // Refresh panel to show selection
        };
        themeContainer.appendChild(btn);
    });

    const getSpritePreview = (frameName) => {
        const div = document.createElement('div');
        const f = Atlas.frames[frameName];
        if (!f) return null;
        div.style.backgroundImage = `url(${Atlas.img.src})`;
        div.style.backgroundPosition = `-${f.x}px -${f.y}px`;
        div.style.width = `${f.w}px`;
        div.style.height = `${f.h}px`;
        return div;
    };

    // Populate Enemies
    const enemyContainer = document.getElementById('gmEnemySelector');
    enemyContainer.innerHTML = '';
    const enemySprites = [...new Set(Object.keys(Atlas.frames).filter(k => k.startsWith('enemy_')).map(k => k.replace(/_\d+$/, '')))];
    Object.entries(CONFIG.ENEMY_TYPES).forEach(([enemyKey, enemyDef]) => {
        const card = document.createElement('div');
        card.className = 'gm-entity-card';
        const currentSpriteDisplay = getSpritePreview(`${state.spriteMap[enemyKey]}_0`);
        if(currentSpriteDisplay) currentSpriteDisplay.className = 'gm-current-sprite';
        
        card.innerHTML = `<h4>${currentSpriteDisplay ? currentSpriteDisplay.outerHTML : ''} ${enemyKey}</h4>`;
        
        const list = document.createElement('div');
        list.className = 'gm-sprite-list';
        enemySprites.forEach(spriteStem => {
            const preview = getSpritePreview(`${spriteStem}_0`);
            if (!preview) return;
            preview.className = 'gm-sprite-preview';
            if (state.spriteMap[enemyKey] === spriteStem) {
                preview.classList.add('selected');
            }
            preview.onclick = () => {
                state.spriteMap[enemyKey] = spriteStem;
                openGmPanel(); // Refresh
            };
            list.appendChild(preview);
        });
        card.appendChild(list);
        enemyContainer.appendChild(card);
    });

    // Populate Towers
    const towerContainer = document.getElementById('gmTowerSelector');
    towerContainer.innerHTML = '';
    const towerSprites = [...new Set(Object.keys(Atlas.frames).filter(k => k.startsWith('tower_')).map(k => k.replace(/_base$|_turret$/, '')))];
    Object.entries(CONFIG.TOWER_TYPES).forEach(([towerKey, towerDef]) => {
        const card = document.createElement('div');
        card.className = 'gm-entity-card';

        const currentSpriteDisplay = getSpritePreview(`${state.spriteMap[towerKey]}_base`);
        if(currentSpriteDisplay) currentSpriteDisplay.className = 'gm-current-sprite';

        card.innerHTML = `<h4>${currentSpriteDisplay ? currentSpriteDisplay.outerHTML : ''} ${towerDef.name}</h4>`;
        
        const list = document.createElement('div');
        list.className = 'gm-sprite-list';
        towerSprites.forEach(spriteStem => {
            const preview = getSpritePreview(`${spriteStem}_base`);
            if (!preview) return;
            preview.className = 'gm-sprite-preview';
            if (state.spriteMap[towerKey] === spriteStem) {
                preview.classList.add('selected');
            }
            preview.onclick = () => {
                state.spriteMap[towerKey] = spriteStem;
                openGmPanel(); // Refresh
            };
            list.appendChild(preview);
        });
        card.appendChild(list);
        towerContainer.appendChild(card);
    });


    document.getElementById('gmModal').classList.add('visible');
}

// ===== Events =====
document.getElementById('btnCitadel').onclick=()=>document.getElementById('citadelModal').classList.add('visible');
document.getElementById('closeCitadelModal').onclick=()=>document.getElementById('citadelModal').classList.remove('visible');
document.getElementById('btnGM').onclick = openGmPanel;
document.getElementById('closeGmModal').onclick = ()=>document.getElementById('gmModal').classList.remove('visible');
document.getElementById('btnSpeed').onclick=()=>{ 
    const speeds = [1, 2, 3, 4];
    let currentIndex = speeds.indexOf(state.speed);
    state.speed = speeds[(currentIndex + 1) % speeds.length];
    document.getElementById('btnSpeed').textContent=`‚è© Speed x${state.speed}`; 
};
document.getElementById('btnStart').onclick=startWave;

function setupWorldSelection(){
    const worldCanvas = document.getElementById('world');
    const wCtx = worldCanvas.getContext('2d');
    const WORLD_COLS = 80;
    const WORLD_ROWS = 50;
    let worldGrid = [];
    let pendingBiome = null;
    let selectedWorldTile = null;

    function generateWorldData() {
        // 1. Initialize with water
        worldGrid = Array(WORLD_ROWS).fill(0).map(() => Array(WORLD_COLS).fill({ type: 'WATER' }));

        // 2. Create landmasses with drunkard's walk
        const numContinents = 5;
        const walkLength = 250;
        for (let i = 0; i < numContinents; i++) {
            let x = Math.floor(Math.random() * WORLD_COLS);
            let y = Math.floor(Math.random() * WORLD_ROWS);

            for (let j = 0; j < walkLength; j++) {
                if (x >= 0 && x < WORLD_COLS && y >= 0 && y < WORLD_ROWS) {
                    worldGrid[y][x] = { type: 'LAND_TEMP' };
                }
                const dir = Math.floor(Math.random() * 4);
                if (dir === 0) x++; else if (dir === 1) x--; else if (dir === 2) y++; else y--;
            }
        }
        
        // 3. Assign biomes based on latitude and some randomness
        const root = getComputedStyle(document.documentElement);
        const biomeKeys = Object.keys(CONFIG.BIOME_MODIFIERS);
        for (let r = 0; r < WORLD_ROWS; r++) {
            for (let c = 0; c < WORLD_COLS; c++) {
                if (worldGrid[r][c].type === 'LAND_TEMP') {
                    const lat = r / WORLD_ROWS;
                    let biomeKey;
                    if (lat < 0.15 || lat > 0.85) { // Poles
                        biomeKey = 'FROSTLANDS';
                    } else if (lat > 0.4 && lat < 0.6) { // Equator
                        biomeKey = Math.random() < 0.6 ? 'DESERT' : 'VOLCANIC';
                    } else { // Temperate
                        biomeKey = 'GRASSLAND';
                    }
                    const biomeData = CONFIG.BIOME_MODIFIERS[biomeKey];
                    const colorVar = biomeData.color.replace('var(', '').replace(')', '');
                    worldGrid[r][c] = {
                        type: biomeKey,
                        key: biomeKey,
                        color: root.getPropertyValue(colorVar).trim()
                    };
                } else {
                    worldGrid[r][c] = { type: 'WATER', color: root.getPropertyValue('--water').trim() };
                }
            }
        }
    }

    function drawWorldMap() {
        const TW = worldCanvas.width / WORLD_COLS;
        const TH = worldCanvas.height / WORLD_ROWS;
        wCtx.clearRect(0, 0, worldCanvas.width, worldCanvas.height);

        for (let r = 0; r < WORLD_ROWS; r++) {
            for (let c = 0; c < WORLD_COLS; c++) {
                wCtx.fillStyle = worldGrid[r][c].color;
                wCtx.fillRect(c * TW, r * TH, TW + 1, TH + 1); // +1 to avoid gaps
            }
        }
        
        // Draw selected character icon
        if (selectedWorldTile) {
            const { c, r } = selectedWorldTile;
            const x = (c + 0.5) * TW;
            const y = (r + 0.5) * TH;
            wCtx.font = `${TW * 1.5}px sans-serif`;
            wCtx.textAlign = 'center';
            wCtx.textBaseline = 'middle';
            wCtx.fillStyle = '#fff';
            wCtx.fillText('üë§', x, y);
            wCtx.strokeStyle = '#000';
            wCtx.lineWidth = 1;
            wCtx.strokeText('üë§', x, y);
        }
    }

    worldCanvas.onclick = e => {
        const rect = worldCanvas.getBoundingClientRect();
        const x = e.clientX - rect.left, y = e.clientY - rect.top;
        const TW = worldCanvas.width / WORLD_COLS;
        const TH = worldCanvas.height / WORLD_ROWS;
        const c = Math.floor(x / TW);
        const r = Math.floor(y / TH);

        if (c < 0 || c >= WORLD_COLS || r < 0 || r >= WORLD_ROWS) return;

        const tile = worldGrid[r][c];
        const preview = document.getElementById('zonePreview');
        const confirmBtn = document.getElementById('btnConfirm');

        if (tile.type !== 'WATER') {
            pendingBiome = tile.key;
            selectedWorldTile = { c, r };
            const biomeData = CONFIG.BIOME_MODIFIERS[pendingBiome];
            preview.innerHTML = `<b>${biomeData.name}:</b> ${biomeData.desc}`;
            confirmBtn.disabled = false;
        } else {
            pendingBiome = null;
            selectedWorldTile = null;
            preview.textContent = '‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ö‡∏ô‡∏ö‡∏Å...';
            confirmBtn.disabled = true;
        }
        drawWorldMap(); // Redraw to show character
    };
    
    document.getElementById('btnConfirm').onclick = async () => {
        if (pendingBiome) {
            Sound.init(); // Initialize Audio on first user gesture
            state.biome = pendingBiome;
            state.mode = 'play';
            document.getElementById('selectionContent').style.display = 'none';
            document.getElementById('loadingOverlay').style.display = 'block';
            await loadAtlas();preloadBiomeBG();
            document.getElementById('worldOverlay').classList.remove('visible');
            toast(`‡∏ï‡∏±‡πâ‡∏á‡∏ê‡∏≤‡∏ô‡πÉ‡∏ô ${CONFIG.BIOME_MODIFIERS[pendingBiome].name}`);
            initGame();
        }
    };
    
    generateWorldData();
    drawWorldMap();
}

// ===== Utilities =====
function resize(){ const w=document.querySelector('section').clientWidth; game.width=w; game.height=w*(CONFIG.GRID.ROWS/CONFIG.GRID.COLS); }
function buildPath(){ const raw=[{c:0,r:7},{c:1,r:7},{c:2,r:7},{c:3,r:7},{c:4,r:7},{c:5,r:6},{c:6,r:5},{c:7,r:5},{c:8,r:5},{c:9,r:5},{c:10,r:6},{c:11,r:7},{c:12,r:8},{c:13,r:8},{c:14,r:8},{c:15,r:8},{c:16,r:7},{c:17,r:6},{c:18,r:6},{c:19,r:6},{c:20,r:6},{c:21,r:7},{c:22,r:7},{c:23,r:7}];
  state.path=raw.map(p=>tileCenter(p.c,p.r)); state.pathGrid=new Set(raw.map(p=>`${p.c},${p.r}`));
}
function TS(){ return { w:game.width/CONFIG.GRID.COLS, h:game.height/CONFIG.GRID.ROWS }; }
function tileCenter(c,r){ const t=TS(); return { x:(c+0.5)*t.w, y:(r+0.5)*t.h }; }
function worldToTile(px,py){ const t=TS(); return { c:Math.floor(px/t.w), r:Math.floor(py/t.h) }; }
function dist(x1,y1,x2,y2){ return Math.hypot(x1-x2, y1-y2); }
function toast(msg){ const el=document.createElement('div'); el.style.cssText='position:fixed;bottom:20px;left:50%;transform:translateX(-50%);background:var(--pri);color:#0b1220;padding:10px 20px;border-radius:8px;z-index:200;font-weight:bold;'; el.textContent=msg; document.body.appendChild(el); setTimeout(()=>el.remove(),2500); }
function nearestPathDistPx(x,y){
  let m = Infinity;
  for(const p of state.path){ const d = dist(x,y,p.x,p.y); if(d<m) m=d; }
  return m;
}
function isTooCloseToPath(c,r){
  const {x,y} = tileCenter(c,r);
  return nearestPathDistPx(x,y) < TS().w * 0.65;
}
function drawBuildOverlay(ctx){
  if(!state.buildMode) return;
  const ts = TS();
  for(let r=0;r<CONFIG.GRID.ROWS;r++){
    for(let c=0;c<CONFIG.GRID.COLS;c++){
      const {x,y} = tileCenter(c,r);
      const onPath = state.pathGrid.has(`${c},${r}`);
      const occupied = [...state.towers, ...state.buildings].some(e=>e.c===c&&e.r===r);
      const tooClose = isTooCloseToPath(c,r);

      let alpha = .14;
      let col   = '#22c55e'; // Green = placeable
      if (onPath || occupied || tooClose){ col = '#ef4444'; alpha = .18; }

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = col;
      const w = ts.w - 4, h = ts.h - 4;
      roundRect(ctx, x-w/2, y-h/2, w, h, 8); ctx.fill();
      ctx.restore();
    }
  }

  const t = worldToTile(state.mouse.x,state.mouse.y);
  if(t.c>=0 && t.r>=0 && t.c<CONFIG.GRID.COLS && t.r<CONFIG.GRID.ROWS){
    const {x,y} = tileCenter(t.c,t.r);
    ctx.save(); ctx.globalAlpha=.35; ctx.strokeStyle='#fff'; ctx.lineWidth=2;
    const w = ts.w - 2, h = ts.h - 2;
    roundRect(ctx, x-w/2, y-h/2, w, h, 10); ctx.stroke(); ctx.restore();
  }
}
function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
}

// Boot
setupWorldSelection();

})();
</script>
</body>
</html>

