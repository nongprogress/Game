<!doctype html>
<html lang="th">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>Idle TD ‚Äî Atlas Update v1.5</title>
<style>
  :root{
    --bg:#0b1220; --card:#0f172a; --line:#243041; --ink:#e2e8f0; --mut:#a8b3c7;
    --pri:#22d3ee; --ok:#22c55e; --warn:#f59e0b; --bad:#ef4444; --yel:#facc15;
    --safe:#2e7d32; --ore:#8d6e63; --bal:#2962ff; --lava:#b91c1c; --ice:#38bdf8; --sand:#ca8a04;
    --bg-grassland:#166534; --path-grassland:#a16207;
    --bg-desert:#b45309; --path-desert:#fde68a;
    --bg-frostlands:#075985; --path-frostlands:#e0f2fe;
    --bg-volcanic:#4f46e5; --path-volcanic:#1e293b;
  }
  *{box-sizing:border-box;-webkit-tap-highlight-color:transparent}
  html,body{height:100%;margin:0}
  body{background:var(--bg);color:var(--ink);font:14px system-ui,Segoe UI,Roboto}
  .wrap{max-width:1400px;margin:0 auto;padding:12px}
  header{position:sticky;top:0;background:#0b1220cc;border-bottom:1px solid var(--line);backdrop-filter:blur(8px);z-index:10}
  .hud{display:flex;flex-wrap:wrap;gap:8px;align-items:center;justify-content:space-between;padding:8px 0}
  .pill{display:flex;align-items:center;gap:6px;background:var(--card);border:1px solid var(--line);border-radius:999px;padding:6px 10px;font-size:12px}
  .btn{cursor:pointer;border:1px solid var(--line);background:linear-gradient(180deg,#1b2636,#131b28);color:var(--ink);padding:8px 12px;border-radius:10px}
  .btn:hover{border-color:#3b4a63}
  .btn:disabled{background:#111a2a;color:var(--mut);border-color:var(--line);cursor:not-allowed}
  .gridWrap{display:grid;grid-template-columns:1fr;gap:12px}
  canvas{display:block;width:100%;height:auto;border:1px solid var(--line);border-radius:12px;cursor:crosshair}
  .panel{background:var(--card);border:1px solid var(--line);border-radius:14px;padding:10px}
  .row{display:flex;flex-wrap:wrap;gap:8px}
  .list{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:8px}
  @media (min-width:1000px){.gridWrap{grid-template-columns:3fr 1fr}}
  .modal{position:fixed;inset:0;background:rgba(2,6,23,.8);backdrop-filter:blur(4px);display:flex;align-items:center;justify-content:center;z-index:100;opacity:0;visibility:hidden;transition:opacity .2s,visibility .2s}
  .modal.visible{opacity:1;visibility:visible}
  .modal-content{background:var(--card);border:1px solid var(--line);border-radius:16px;padding:14px;width:90%;max-width:500px;max-height:85vh;overflow-y:auto}
  .modal-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
  .tier{border:1px solid var(--line);padding:10px;border-radius:10px;margin-bottom:10px;background:#0b1220}
  .tier h4{margin:0 0 8px}
  .tier p{font-size:12px;color:var(--mut);margin:0 0 8px}
  #loadingOverlay{color:white;font-size:1.5em;text-align:center}
</style>
</head>
<body>
<header class="wrap">
  <div class="hud">
    <div class="row">
      <div class="pill">üèõÔ∏è ‡∏ê‡∏≤‡∏ô‡∏ó‡∏±‡∏û: <b id="citadelHP">100</b>/<b id="citadelMaxHP">100</b> (Tier <b id="citadelTier">1</b>)</div>
      <div class="pill">üí∞ <b id="gold">0</b></div>
      <div class="pill">‚õèÔ∏è <b id="ore">0</b></div>
      <div class="pill">‚öôÔ∏è <b id="components">0</b></div>
      <div class="pill">üî© <b id="gears">0</b></div>
      <div class="pill">üíé <b id="cores">0</b></div>
      <div class="pill">üåä Wave <b id="wave">0</b></div>
    </div>
    <div class="row">
      <button class="btn" id="btnStart">‚ñ∂ Start Wave</button>
      <button class="btn" id="btnCitadel">üèõÔ∏è ‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏ê‡∏≤‡∏ô‡∏ó‡∏±‡∏û</button>
      <button class="btn" id="btnSpeed">‚è© Speed x1</button>
    </div>
  </div>
</header>

<main class="wrap gridWrap">
  <section><canvas id="game" width="1280" height="720"></canvas></section>
  <aside class="panel">
    <h3 style="margin:0 0 8px">‡∏™‡∏¥‡πà‡∏á‡∏Å‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á (Tier <span id="buildTier">1</span>)</h3>
    <div class="list" id="buildMenu"></div>
    <h3 style="margin:12px 0 8px">‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å</h3>
    <div id="selectedInfo" class="panel" style="min-height:120px;background:#0b1220;padding:8px">
      <small style="color:var(--mut)">‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏õ‡πâ‡∏≠‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î</small>
    </div>
  </aside>
</main>

<!-- Citadel Upgrade Modal -->
<div id="citadelModal" class="modal">
  <div class="modal-content">
    <div class="modal-header">
      <h2>‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏ê‡∏≤‡∏ô‡∏ó‡∏±‡∏û</h2>
      <button id="closeCitadelModal" class="btn">√ó</button>
    </div>
    <div id="citadelTiers"></div>
  </div>
</div>

<div id="worldOverlay" class="modal visible">
  <div id="loadingOverlay" style="display:none;"><p>‡∏Å‡∏≥‡∏•‡∏±‡∏á‡πÇ‡∏´‡∏•‡∏î‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£...</p></div>
  <div id="selectionContent" class="modal-content" style="max-width:960px">
    <h3>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡∏±‡πâ‡∏á‡∏ê‡∏≤‡∏ô‡∏ö‡∏ô‡πÅ‡∏ú‡∏ô‡∏ó‡∏µ‡πà‡πÇ‡∏•‡∏Å</h3>
    <div class="legend" style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px;">
      <span><i style="display:inline-block;width:10px;height:10px;background:var(--safe);border-radius:2px"></i> ‡∏ó‡∏∏‡πà‡∏á‡∏´‡∏ç‡πâ‡∏≤</span>
      <span><i style="display:inline-block;width:10px;height:10px;background:var(--sand);border-radius:2px"></i> ‡∏ó‡∏∞‡πÄ‡∏•‡∏ó‡∏£‡∏≤‡∏¢</span>
      <span><i style="display:inline-block;width:10px;height:10px;background:var(--ice);border-radius:2px"></i> ‡πÅ‡∏î‡∏ô‡∏ô‡πâ‡∏≥‡πÅ‡∏Ç‡πá‡∏á</span>
      <span><i style="display:inline-block;width:10px;height:10px;background:var(--lava);border-radius:2px"></i> ‡πÄ‡∏Ç‡∏ï‡∏†‡∏π‡πÄ‡∏Ç‡∏≤‡πÑ‡∏ü</span>
    </div>
    <canvas id="world" width="960" height="540"></canvas>
    <div id="zonePreview" style="margin-top:10px;min-height:40px;">‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà...</div>
    <button class="btn" id="btnConfirm" disabled style="width:100%;margin-top:10px">‚úÖ ‡∏¢‡∏∑‡∏ô‡∏¢‡∏±‡∏ô‡∏ï‡∏±‡πâ‡∏á‡∏ê‡∏≤‡∏ô‡∏ó‡∏µ‡πà‡∏ô‡∏µ‡πà</button>
  </div>
</div>

<script>
(async function(){

// ===== Atlas Loader (Global) =====
const Atlas = { img:new Image(), frames:{}, ready:false };
function normalizeFrames(map){
  if (map.frames && !Array.isArray(map.frames)) return map.frames;       // {frames:{name:{x,y,w,h}}}
  if (Array.isArray(map.frames)) {                                       // [{filename, frame:{x,y,w,h}}]
    const out={};
    for(const f of map.frames){
      const n=(f.filename||'').replace(/\.(png|jpe?g)$/i,'');
      const fr=f.frame||f; out[n]={x:fr.x,y:fr.y,w:fr.w,h:fr.h,pivot:f.pivot||{x:.5,y:.5}};
    }
    return out;
  }
  return {};
}
async function loadAtlas(png='assets/atlas.png', json='assets/atlas.json'){
  try{
    const map = await fetch(json).then(r=>r.json());
    Atlas.frames = (map.frames && !Array.isArray(map.frames)) ? map.frames
                 : Array.isArray(map.frames)
                 ? Object.fromEntries(map.frames.map(f=>[(f.filename||'').replace(/\.(png|jpe?g)$/i,''), f.frame||f]))
                 : map;
    await new Promise(res=>{ Atlas.img.onload=res; Atlas.img.onerror=res; Atlas.img.src = png; });
    Atlas.ready = true;
    autoAliasFramesV2();                // ‚Üê ‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç
    console.log('[Atlas] ready', Object.keys(Atlas.frames).length);
  }catch(e){ console.warn('[Atlas] load failed', e); Atlas.ready=false; }
}
function drawFrame(ctx, name, x, y, w, h, rot=0){
  const f = Atlas.frames?.[name]; if(!Atlas.ready || !f) return false;
  ctx.save(); ctx.translate(x,y); if(rot) ctx.rotate(rot);
  ctx.drawImage(Atlas.img, f.x,f.y,f.w,f.h, -w/2,-h/2, w,h);
  ctx.restore(); return true;
}
window.Atlas=Atlas; window.drawFrame=drawFrame; // ‡πÉ‡∏´‡πâ‡πÄ‡∏ä‡πá‡∏Ñ‡πÉ‡∏ô Console ‡πÑ‡∏î‡πâ
// === Patterns & Ground ===
function getPattern(ctx, frameName, scale=1){
  getPattern.cache ??= {};
  const key = frameName+'@'+scale;
  if(getPattern.cache[key]) return getPattern.cache[key];
  const f = Atlas.frames?.[frameName]; if(!f) return null;
  const off = document.createElement('canvas');
  off.width = Math.max(2, Math.floor(f.w*scale));
  off.height= Math.max(2, Math.floor(f.h*scale));
  const oc = off.getContext('2d');
  oc.imageSmoothingEnabled = false;
  oc.drawImage(Atlas.img, f.x,f.y,f.w,f.h, 0,0, off.width, off.height);
  const pat = ctx.createPattern(off, 'repeat');
  return (getPattern.cache[key] = pat);
}

// ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏ü‡∏£‡∏°‡∏à‡∏≤‡∏Å atlas ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡πÉ‡∏ä‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏û‡∏∑‡πâ‡∏ô/‡∏ó‡∏≤‡∏á (‡∏õ‡∏£‡∏±‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö atlas ‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ)
const THEME = {
  grassFrame: 'landscape_05',  // ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏ç‡πâ‡∏≤
  pathFrame : 'landscape_22',  // ‡∏ó‡∏≤‡∏á‡∏î‡∏¥‡∏ô/‡∏ó‡∏£‡∏≤‡∏¢
};

function drawGround(ctx){
  // ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏ü‡∏£‡∏° ‡πÉ‡∏ä‡πâ‡∏™‡∏µ fallback
  const pat = getPattern(ctx, THEME.grassFrame, 0.5);
  if(pat){ ctx.fillStyle = pat; ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height); }
  else{
    const root = getComputedStyle(document.documentElement);
    const biomeBg = root.getPropertyValue(`--bg-${state.biome.toLowerCase()}`).trim();
    ctx.fillStyle = biomeBg || '#134e4a';
    ctx.fillRect(0,0,ctx.canvas.width, ctx.canvas.height);
  }
}

function drawPath(ctx){
  // ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ó‡∏≤‡∏á‡πÅ‡∏ö‡∏ö 2 ‡∏ä‡∏±‡πâ‡∏ô (‡∏Ç‡∏≠‡∏ö‡πÄ‡∏Ç‡πâ‡∏° + ‡πÑ‡∏™‡πâ‡∏ó‡∏≤‡∏á‡∏™‡∏ß‡πà‡∏≤‡∏á)
  const ts = TS();
  const wOuter = ts.w * 1.20;   // ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏Ç‡∏≠‡∏ö‡∏ô‡∏≠‡∏Å
  const wInner = ts.w * 0.90;   // ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡πÑ‡∏™‡πâ‡∏ó‡∏≤‡∏á
  const root = getComputedStyle(document.documentElement);
  const pathFallback = root.getPropertyValue(`--path-${state.biome.toLowerCase()}`).trim() || '#a16207';

  // ‡∏Ç‡∏≠‡∏ö‡∏ó‡∏≤‡∏á (‡πÄ‡∏á‡∏≤)
  ctx.save();
  ctx.lineCap='round'; ctx.lineJoin='round';
  ctx.shadowColor='rgba(0,0,0,.35)'; ctx.shadowBlur=8; ctx.shadowOffsetY=2;
  ctx.strokeStyle = 'rgba(0,0,0,.25)'; ctx.lineWidth = wOuter;
  ctx.beginPath(); for(const p of state.path) ctx.lineTo(p.x, p.y); ctx.stroke();
  ctx.restore();

  // ‡πÑ‡∏™‡πâ‡∏ó‡∏≤‡∏á‡∏î‡πâ‡∏ß‡∏¢ pattern (‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ ‡πÉ‡∏ä‡πâ‡∏™‡∏µ fallback)
  ctx.save();
  ctx.lineCap='round'; ctx.lineJoin='round';
  const pat = getPattern(ctx, THEME.pathFrame, 0.6);
  ctx.strokeStyle = pat || pathFallback;
  ctx.lineWidth = wInner;
  ctx.beginPath(); for(const p of state.path) ctx.lineTo(p.x, p.y); ctx.stroke();
  ctx.restore();

  // ‡∏à‡∏∏‡∏î gravel ‡πÄ‡∏•‡πá‡∏Å‡πÜ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏°‡∏µ‡∏ä‡∏µ‡∏ß‡∏¥‡∏ï
  ctx.save();
  ctx.globalAlpha = .25;
  for (let i=0; i<80; i++){
    const idx = Math.floor(Math.random()*(state.path.length-1));
    const a = state.path[idx], b = state.path[idx+1];
    if(!b) continue;
    const t = Math.random(); const x = a.x + (b.x-a.x)*t, y = a.y + (b.y-a.y)*t;
    const dx = (Math.random()-.5)*wInner*0.9, dy = (Math.random()-.5)*wInner*0.9;
    ctx.fillStyle = '#3f2d20'; ctx.beginPath(); ctx.arc(x+dx, y+dy, Math.random()*2+0.5, 0, Math.PI*2); ctx.fill();
  }
  ctx.restore();
}

function autoAliasFramesV2(){
  const F = Atlas.frames; if(!F) return;
  const keys = Object.keys(F);
  const groups = {};
  for(const k of keys){
    const m = k.match(/^([a-z0-9]+?)(?:[_\-](\d+))?$/i);
    if(!m) continue;
    const stem = m[1].toLowerCase();
    const idx  = m[2] ? parseInt(m[2],10) : Number.POSITIVE_INFINITY;
    const fr = F[k]; const area = (fr.w||0)*(fr.h||0);
    (groups[stem] ||= []).push({ key:k, idx, area });
  }
  for(const arr of Object.values(groups)){
    arr.sort((a,b)=> (a.idx - b.idx) || (b.area - a.area));
  }

  const pickStem = (prio, used=new Set())=>{
    for(const s of prio) if(groups[s] && !used.has(s)) return s;
    const bad = new Set(['tower','trees','tree','rocks','rock','landscape','bg','background','hud','ui']);
    let best=null, score=-1;
    for(const [s,arr] of Object.entries(groups)){
      if(used.has(s) || bad.has(s)) continue;
      const sc = arr.length*100000 + (arr[0]?.area||0);
      if(sc>score){ score=sc; best=s; }
    }
    if(best) return best;
    if(groups['crystals'] && !used.has('crystals')) return 'crystals';
    for(const [s,arr] of Object.entries(groups)){
      if(used.has(s)) continue;
      const sc = arr.length*100000 + (arr[0]?.area||0);
      if(sc>score){ score=sc; best=s; }
    }
    return best;
  };

  const used = new Set();
  const enemyPlan = [
    { type:'runner', prio:['crystals','crystal','slime','goblin','orc'] },
    { type:'brute',  prio:['rocks','rock','golem','brute'] },
    { type:'flyer',  prio:['bat','fly','bird','harpy','flyer'] },
    { type:'boss',   prio:['boss','dragon','demon','crystals'] },
  ];

  for(const e of enemyPlan){
    const s = pickStem(e.prio, used); if(!s) continue;
    used.add(s);
    const arr = groups[s];
    for(let i=0;i<6;i++){
      const src = arr[i % arr.length].key;
      F[`enemy_${e.type}_${i}`] = F[src];
    }
    console.log('[alias] enemy', e.type, '‚Üê', s, `(${arr.length} frames)`);
  }

  const tarr = (groups['tower']||[]).slice().sort((a,b)=> (b.area - a.area) || (a.idx - b.idx));
  const types = ['gun','frost','rocket','artillery'];
  for(let i=0;i<types.length;i++){
    const base   = tarr.shift()?.key;
    const turret = tarr.shift()?.key;
    if(base)   F[`tower_${types[i]}_base`]   = F[base];
    if(turret) F[`tower_${types[i]}_turret`] = F[turret];
    console.log('[alias] tower', types[i], '‚Üê', base, '/', turret);
  }

  const rocks = groups['rocks'] || groups['rock'];
  if(rocks?.length) F['mine'] = F[rocks[0].key];

  if(!F['bullet']) console.log('[alias] bullet: none (use code fallback)');
}
// ===== GAME CONFIG =====
const CONFIG = {
  GRID:{ COLS:24, ROWS:14 },
  CITADEL_TIERS:{
    1:{ hp:100, unlocks:['GUN','MINE'] },
    2:{ hp:150, cost:{gold:100,components:50}, unlocks:['FROST','ROCKET'] },
    3:{ hp:220, cost:{gold:1200,gears:25}, unlocks:['ARTILLERY','BARRACKS'] },
    4:{ hp:350, cost:{gold:3000,cores:5}, unlocks:['METEOR_STRIKE'] }
  },
  TOWER_TYPES:{
  GUN:{
    name:'‡∏õ‡πâ‡∏≠‡∏°‡∏õ‡∏∑‡∏ô‡∏Å‡∏•', tier:1,
    cost:{ gold:30, ore:0 },
    stats:{ dmg:35, range:2.3, rate:5.9, projectileSpeed:450 },
    upgrades:{
      dmg:   { label:'+DMG',   cost:{ ore:10 }, mul:1.20 },
      range: { label:'+RANGE', cost:{ ore:15 }, mul:1.10 },
      rate:  { label:'+RATE',  cost:{ ore:12 }, mul:1.12 }
    }
  },
  FROST:{
    name:'‡∏õ‡πâ‡∏≠‡∏°‡∏ô‡πâ‡∏≥‡πÅ‡∏Ç‡πá‡∏á', tier:2,
    cost:{ gold:80, ore:10 },
    stats:{ dmg:45, range:2.1, rate:1.2, slow:0.35, projectileSpeed:350 },
    upgrades:{
      dmg:   { label:'+DMG',   cost:{ ore:15 }, mul:1.30 },
      range: { label:'+RANGE', cost:{ ore:15 }, mul:1.10 },
      slow:  { label:'+SLOW',  cost:{ ore:20 }, mul:1.15 }
    }
  },
  ROCKET:{
    name:'‡∏õ‡πâ‡∏≠‡∏°‡∏à‡∏£‡∏ß‡∏î', tier:2,
    cost:{ gold:120, ore:30 },
    stats:{ dmg:40, range:2.8, rate:0.4, splash:1.0, projectileSpeed:300 },
    upgrades:{
      dmg:    { label:'+DMG',    cost:{ ore:40 }, mul:1.25 },
      range:  { label:'+RANGE',  cost:{ ore:30 }, mul:1.08 },
      splash: { label:'+SPLASH', cost:{ ore:50 }, mul:1.20 }
    }
  },
  ARTILLERY:{
    name:'‡∏õ‡πâ‡∏≠‡∏°‡∏õ‡∏∑‡∏ô‡πÉ‡∏´‡∏ç‡πà', tier:3,
    cost:{ gold:200, ore:50 },
    stats:{ dmg:80, range:4.5, rate:0.25, splash:1.5, minRange:1.8, projectileSpeed:200 },
    upgrades:{
      dmg:    { label:'+DMG',    cost:{ ore:80 },  mul:1.20 },
      range:  { label:'+RANGE',  cost:{ ore:60 },  mul:1.10 },
      splash: { label:'+SPLASH', cost:{ ore:100 }, mul:1.15 }
    }
  }
},
  BUILDING_TYPES:{
    MINE:{ name:'‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏á‡πÅ‡∏£‡πà', tier:1, cost:{gold:40,ore:0}, stats:{ rate:5, yield:2 } },
    BARRACKS:{ name:'‡∏Ñ‡πà‡∏≤‡∏¢‡∏ó‡∏´‡∏≤‡∏£', tier:3, cost:{gold:150,ore:20}, limit:1 }
  },
  ENEMY_TYPES:{
    RUNNER:{ hp:80, speed:60, reward:20, type:'normal' },
    BRUTE:{ hp:250, speed:40, reward:50, type:'elite' },
    FLYER:{ hp:100, speed:75, reward:80, type:'normal', flying:true },
    BOSS:{ hp:2000, speed:35, reward:100, type:'boss' }
  },
  WAVE_COMPOSITION:[
    {RUNNER:10},{RUNNER:15},{RUNNER:10,BRUTE:2},{RUNNER:20,FLYER:5},{BRUTE:8,FLYER:5},
    {RUNNER:25,BRUTE:5},{FLYER:15,BRUTE:5},{RUNNER:20,BRUTE:10},{BRUTE:15,FLYER:10},{BOSS:1,RUNNER:20}
  ],
  BIOME_MODIFIERS:{
    GRASSLAND:{ name:'‡∏ó‡∏∏‡πà‡∏á‡∏´‡∏ç‡πâ‡∏≤', desc:'‡∏™‡∏°‡∏î‡∏∏‡∏• ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ú‡∏•‡∏û‡∏¥‡πÄ‡∏®‡∏©', color:'var(--safe)', background:'var(--bg-grassland)', path:'var(--path-grassland)', mods:{} },
    DESERT:{ name:'‡∏ó‡∏∞‡πÄ‡∏•‡∏ó‡∏£‡∏≤‡∏¢', desc:'‡∏õ‡πâ‡∏≠‡∏°‡∏¢‡∏¥‡∏á‡∏ä‡πâ‡∏≤‡∏•‡∏á 5%, ‡∏®‡∏±‡∏ï‡∏£‡∏π HP -10%', color:'var(--sand)', background:'var(--bg-desert)', path:'var(--path-desert)', mods:{ towerRate:0.95, enemyHP:0.9 } },
    FROSTLANDS:{ name:'‡πÅ‡∏î‡∏ô‡∏ô‡πâ‡∏≥‡πÅ‡∏Ç‡πá‡∏á', desc:'Frost Tower ‡∏™‡πÇ‡∏•‡∏ß‡πå x1.2, ‡∏õ‡πâ‡∏≠‡∏° AOE Dmg -15%', color:'var(--ice)', background:'var(--bg-frostlands)', path:'var(--path-frostlands)', mods:{ frostSlow:1.2, splashDmg:0.85 } },
    VOLCANIC:{ name:'‡πÄ‡∏Ç‡∏ï‡∏†‡∏π‡πÄ‡∏Ç‡∏≤‡πÑ‡∏ü', desc:'‡∏®‡∏±‡∏ï‡∏£‡∏π‡∏ï‡πâ‡∏≤‡∏ô‡∏ó‡∏≤‡∏ô AOE, ‡∏î‡∏£‡∏≠‡∏õ‡πÅ‡∏£‡πà‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô', color:'var(--lava)', background:'var(--bg-volcanic)', path:'var(--path-volcanic)', mods:{ enemySplashResist:0.2, oreYield:1.25 } }
  },
  ENEMY_DROPS:{
    normal:{ components:0.15, gears:0.03 },
    elite:{ components:0.4, gears:0.1 },
    boss:{ components:1, gears:0.5, cores:1 }
  }
};

const state = {
  mode:'map-select', citadelTier:1, citadelHP:100,
  gold:200, ore:50, components:0, gears:0, cores:0,
  wave:0, speed:1,
  towers:[], buildings:[], enemies:[], bullets:[], effects:[], path:[], pathGrid:new Set(),
  lastTime:0, buildMode:null, selectedEntity:null,
  biome:'GRASSLAND', mouse:{x:0,y:0}, decorations:[]
};

const game = document.getElementById('game');
const g = game.getContext('2d');
const buildMenu = document.getElementById('buildMenu');

// ===== Core Classes =====
class Entity{ constructor(c,r){ this.c=c; this.r=r; const {x,y}=tileCenter(c,r); this.x=x; this.y=y; } center(){ return {x:this.x,y:this.y}; } update(dt){} draw(ctx){} }

class Tower extends Entity{
  constructor(c,r,key){ super(c,r); this.key=key; this.type='tower';
    this.def=CONFIG.TOWER_TYPES[key]; this.stats=JSON.parse(JSON.stringify(this.def.stats));
    this.cooldown=0; this.target=null; this.angle=0; this.level=1; this.invested=this.def.cost;
  }
  update(dt){
    this.cooldown -= dt;
    if(this.target && (!this.target.alive || dist(this.x,this.y,this.target.x,this.target.y) > this.stats.range*TS().w)){ this.target=null; }
    if(!this.target) this.findTarget();
    if(this.target){ this.angle = Math.atan2(this.target.y - this.y, this.target.x - this.x); if(this.cooldown<=0) this.shoot(); }
  }
  findTarget(){
    let best=null, maxProg=-1;
    for(const e of state.enemies){
      if(e.def.flying && this.key==='ROCKET') continue;
      const d=dist(this.x,this.y,e.x,e.y);
      if(d <= this.stats.range*TS().w && e.pathProgress>maxProg){ best=e; maxProg=e.pathProgress; }
    }
    this.target = best;
  }
  shoot(){
    const rateMod = CONFIG.BIOME_MODIFIERS[state.biome].mods.towerRate || 1;
    this.cooldown = 1 / (this.stats.rate * rateMod);
    state.bullets.push(new Bullet(this.x, this.y, this.target, this));
  }
  draw(ctx){
    const size = TS().w * 0.8;
    const baseName   = `tower_${this.key.toLowerCase()}_base`;
    const turretName = `tower_${this.key.toLowerCase()}_turret`;

    // Base
    if(!drawFrame(ctx, baseName, this.x, this.y, size, size)){
      ctx.fillStyle = '#475569'; ctx.beginPath(); ctx.arc(this.x,this.y,15,0,Math.PI*2); ctx.fill();
    }
    // Turret (rotated)
    ctx.save(); ctx.translate(this.x,this.y); ctx.rotate(this.angle + Math.PI/2);
    ctx.shadowColor='rgba(0,0,0,.35)'; ctx.shadowBlur=8; ctx.shadowOffsetY=4;
    if(!drawFrame(ctx, turretName, 0, 0, size, size)){
      ctx.fillStyle = '#22d3ee'; ctx.fillRect(-4,-4,8,20);
    }
    ctx.restore();

    // Range ring when selected
    if(state.selectedEntity===this){
      ctx.save(); ctx.globalAlpha=.2; ctx.fillStyle='#fff'; ctx.beginPath();
      ctx.arc(this.x,this.y,this.stats.range*TS().w,0,Math.PI*2); ctx.fill(); ctx.restore();
    }
  }
}

class Building extends Entity{
  constructor(c,r,key){ super(c,r); this.key=key; this.type='building'; this.def=CONFIG.BUILDING_TYPES[key]; this.timer=0; }
  update(dt){
    if(this.key==='MINE'){
      this.timer += dt;
      if(this.timer >= this.def.stats.rate){
        this.timer = 0;
        const oreMod = CONFIG.BIOME_MODIFIERS[state.biome].mods.oreYield || 1;
        state.ore += this.def.stats.yield * oreMod;
        state.effects.push(new FloatingText(`+${Math.round(this.def.stats.yield*oreMod)} Ore`, this.x, this.y));
      }
    }
  }
  draw(ctx){
    const size = TS().w * 0.9;
    if(!drawFrame(ctx, this.key.toLowerCase(), this.x, this.y, size, size)){
      const ts=TS(); ctx.fillStyle='#94a3b8'; ctx.fillRect(this.x-ts.w/2+4, this.y-ts.h/2+4, ts.w-8, ts.h-8);
      ctx.fillStyle='#facc15'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(this.key==='MINE'?'‚õèÔ∏è':'üèõÔ∏è', this.x, this.y);
    }
  }
}

class Enemy{
  constructor(key){
    this.key=key; this.def=CONFIG.ENEMY_TYPES[key];
    const startPos=state.path[0]; this.x=startPos.x; this.y=startPos.y;
    this.pathIndex=0; this.pathProgress=0;
    const hpMod = CONFIG.BIOME_MODIFIERS[state.biome].mods.enemyHP || 1;
    this.maxHp = Math.floor(this.def.hp * (1 + state.wave * 0.1) * hpMod);
    this.hp=this.maxHp; this.alive=true; this.slowTimer=0; this.slowFactor=1;
    this.animT=0;
  }
  update(dt){
    this.animT += dt;
    if(this.slowTimer>0) this.slowTimer -= dt; else this.slowFactor=1;
    const target = state.path[this.pathIndex+1];
    if(!target){ this.alive=false; state.citadelHP--; if(state.citadelHP<=0) toast("‡∏ê‡∏≤‡∏ô‡∏ó‡∏±‡∏û‡∏ñ‡∏π‡∏Å‡∏ó‡∏≥‡∏•‡∏≤‡∏¢!"); return; }
    const angle=Math.atan2(target.y - this.y, target.x - this.x);
    const speed=this.def.speed * this.slowFactor * dt;
    this.x += Math.cos(angle)*speed; this.y += Math.sin(angle)*speed;
    this.pathProgress += speed; if(dist(this.x,this.y,target.x,target.y)<5) this.pathIndex++;
  }
  takeDamage(dmg, splashResistMod=0){
    const finalDmg = dmg * (1 - splashResistMod);
    this.hp -= finalDmg;
    if(this.hp<=0 && this.alive){
      this.alive=false; state.gold += this.def.reward;
      const drop = CONFIG.ENEMY_DROPS[this.def.type];
      if(drop){ for(const [item,ch] of Object.entries(drop)){ if(Math.random()<ch){ state[item]++; state.effects.push(new FloatingText(`+1 ${item}`, this.x, this.y-20)); updateHUD(); } } }
    }
  }
  draw(ctx){
    const size = this.key==='BOSS'?40:24;
    const base = `enemy_${this.key.toLowerCase()}`;
    const fi = Math.floor(this.animT*10)%6;
    let ok = drawFrame(ctx, `${base}_${fi}`, this.x, this.y, size*2, size*2);
    if(!ok) ok = drawFrame(ctx, base, this.x, this.y, size*2, size*2);
    if(!ok){
      ctx.save(); ctx.translate(this.x,this.y);
      ctx.shadowColor='rgba(0,0,0,.25)'; ctx.shadowBlur=6; ctx.shadowOffsetY=3;
      if(this.key==='RUNNER'){ ctx.fillStyle='#ef4444'; ctx.beginPath(); ctx.arc(0,0,10,0,Math.PI*2); ctx.fill(); }
      if(this.key==='BRUTE'){ ctx.fillStyle='#a855f7'; ctx.fillRect(-10,-10,20,20); }
      if(this.key==='FLYER'){ ctx.fillStyle='#eab308'; ctx.beginPath(); ctx.moveTo(0,-10);ctx.lineTo(10,10);ctx.lineTo(-10,10);ctx.closePath();ctx.fill(); }
      if(this.key==='BOSS'){ ctx.fillStyle='#dc2626'; ctx.beginPath(); ctx.arc(0,0,16,0,Math.PI*2); ctx.fill(); }
      ctx.restore();
    }

    if(this.slowTimer>0){ ctx.strokeStyle='#38bdf8'; ctx.lineWidth=2; ctx.globalAlpha=.7; ctx.beginPath(); ctx.arc(this.x,this.y,size,0,Math.PI*2); ctx.stroke(); ctx.globalAlpha=1; }
    const barY=this.y-size-5; ctx.fillStyle='#1e293b'; ctx.fillRect(this.x-15,barY,30,4); ctx.fillStyle='#16a34a'; ctx.fillRect(this.x-15,barY,30*(this.hp/this.maxHp),4);
  }
}

class Bullet{
  constructor(x,y,target,tower){ this.x=x; this.y=y; this.target=target; this.tower=tower; this.alive=true; }
  update(dt){
    if(!this.target.alive){ this.alive=false; return; }
    const angle=Math.atan2(this.target.y-this.y, this.target.x-this.x);
    const speed=this.tower.stats.projectileSpeed*dt; this.x+=Math.cos(angle)*speed; this.y+=Math.sin(angle)*speed;
    if(dist(this.x,this.y,this.target.x,this.target.y)<10) this.hit();
  }
  hit(){
    this.alive=false;
    const splashMod = CONFIG.BIOME_MODIFIERS[state.biome].mods.splashDmg || 1;
    const splashRes = CONFIG.BIOME_MODIFIERS[state.biome].mods.enemySplashResist || 0;
    if(this.tower.stats.splash>0){
      state.effects.push(new Explosion(this.target.x,this.target.y,this.tower.stats.splash*TS().w));
      state.enemies.forEach(e=>{ if(dist(this.target.x,this.target.y,e.x,e.y) < this.tower.stats.splash*TS().w){ e.takeDamage(this.tower.stats.dmg*splashMod, splashRes); } });
    }else{
      this.target.takeDamage(this.tower.stats.dmg);
    }
    if(this.tower.stats.slow>0){ const slowMod = CONFIG.BIOME_MODIFIERS[state.biome].mods.frostSlow || 1; this.target.slowFactor = 1 - (this.tower.stats.slow*slowMod); this.target.slowTimer = 2; }
  }
  draw(ctx){
    // ‡πÑ‡∏°‡πà‡πÉ‡∏ä‡πâ‡πÄ‡∏ü‡∏£‡∏°‡∏Å‡∏£‡∏∞‡∏™‡∏∏‡∏ô‡∏Å‡πá‡πÑ‡∏î‡πâ ‡πÉ‡∏ä‡πâ‡∏ß‡∏á‡∏Å‡∏•‡∏°‡∏á‡πà‡∏≤‡∏¢ ‡πÜ
    if(this.tower.key==='GUN') ctx.fillStyle='#67e8f9';
    else if(this.tower.key==='FROST') ctx.fillStyle='#7dd3fc';
    else if(this.tower.key==='ROCKET') ctx.fillStyle='#fb923c';
    else ctx.fillStyle='#94a3b8';
    ctx.beginPath(); ctx.arc(this.x,this.y,4,0,Math.PI*2); ctx.fill();
  }
}

class Effect{ constructor(x,y){ this.x=x; this.y=y; this.alive=true; this.life=1; } update(dt){ this.life-=dt; if(this.life<=0) this.alive=false; } draw(ctx){} }
class Explosion extends Effect{
  constructor(x,y,radius){ super(x,y); this.radius=radius; this.life=0.4; }
  draw(ctx){
    const p = 1 - (this.life/0.4);
    // ‡πÉ‡∏ä‡πâ‡πÄ‡∏ü‡∏£‡∏° vfx ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ
    const fi = Math.min(5, Math.floor(p*6));
    if(!drawFrame(ctx, `vfx_explosion_${fi}`, this.x, this.y, this.radius, this.radius)){
      ctx.beginPath(); ctx.arc(this.x, this.y, this.radius * p, 0, Math.PI*2);
      ctx.fillStyle = `rgba(251,146,60,${1-p})`; ctx.fill();
    }
  }
}
class FloatingText extends Effect{
  constructor(text,x,y){ super(x,y); this.text=text; this.life=1.2; }
  update(dt){ super.update(dt); this.y -= 20*dt; }
  draw(ctx){ ctx.font='bold 12px Segoe UI'; ctx.fillStyle=`rgba(250,250,250,${this.life/1.2})`; ctx.textAlign='center'; ctx.fillText(this.text,this.x,this.y); }
}

// ===== Logic =====
function initGame(){
  resize(); window.addEventListener('resize',resize);
  game.addEventListener('mousemove', e=>{ const r=game.getBoundingClientRect(); state.mouse.x=e.clientX-r.left; state.mouse.y=e.clientY-r.top; });
  game.addEventListener('click', handleCanvasClick);
  window.addEventListener('keydown', e=>{ if(e.key==='Escape'){ if(state.buildMode){ state.buildMode=null; toast('‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á'); } else if(state.selectedEntity){ state.selectedEntity=null; updateSelectedInfo(); toast('‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡πÄ‡∏•‡∏∑‡∏≠‡∏Å'); } }});
  buildPath(); updateCitadelUI(); updateBuildMenu(); updateHUD();
  state.citadelHP = CONFIG.CITADEL_TIERS[state.citadelTier].hp;
  generateDecorations(); loop(0);
}
function generateDecorations(){ for(let i=0;i<50;i++){ const c=Math.floor(Math.random()*CONFIG.GRID.COLS), r=Math.floor(Math.random()*CONFIG.GRID.ROWS); if(!state.pathGrid.has(`${c},${r}`)) state.decorations.push({c,r}); } }
function startWave(){
  if(state.enemies.length>0) return toast("‡∏Å‡∏≥‡∏à‡∏±‡∏î‡∏®‡∏±‡∏ï‡∏£‡∏π‡πÉ‡∏´‡πâ‡∏´‡∏°‡∏î‡∏Å‡πà‡∏≠‡∏ô");
  state.wave++;
  const waveData = CONFIG.WAVE_COMPOSITION[(state.wave-1)%CONFIG.WAVE_COMPOSITION.length];
  let spawnQueue=[]; for(const [k,c] of Object.entries(waveData)){ for(let i=0;i<c;i++) spawnQueue.push(k); }
  const spawnInterval = setInterval(()=>{ if(spawnQueue.length>0){ state.enemies.push(new Enemy(spawnQueue.shift())); } else { clearInterval(spawnInterval); } }, 800/state.speed);
}
function handleCanvasClick(){
  const {c,r} = worldToTile(state.mouse.x, state.mouse.y);
  if(c<0||r<0||c>=CONFIG.GRID.COLS||r>=CONFIG.GRID.ROWS) return;

  if(state.buildMode){
    // ‡∏Å‡∏±‡∏ô‡∏Å‡πà‡∏≠‡∏ô‡∏Å‡∏î‡∏™‡∏£‡πâ‡∏≤‡∏á
    if (isTooCloseToPath(c,r)) return toast('‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ');
    placeEntity(c,r);
  } else {
    const hit=[...state.towers,...state.buildings].find(e=>e.c===c && e.r===r);
    state.selectedEntity=hit||null;
    updateSelectedInfo();
  }
}
function placeEntity(c,r){
  if(state.pathGrid.has(`${c},${r}`)) return toast("‡πÑ‡∏°‡πà‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏ö‡∏ô‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏ô‡πÑ‡∏î‡πâ");
  if(isTooCloseToPath(c,r))           return toast('‡πÉ‡∏Å‡∏•‡πâ‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ');
  if([...state.towers,...state.buildings].some(e=>e.c===c && e.r===r)) return toast("‡∏°‡∏µ‡∏™‡∏¥‡πà‡∏á‡∏Å‡πà‡∏≠‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß");

  const key=state.buildMode, isTower=!!CONFIG.TOWER_TYPES[key];
  const def=isTower?CONFIG.TOWER_TYPES[key]:CONFIG.BUILDING_TYPES[key];

  if(state.gold>=def.cost.gold && state.ore>=(def.cost.ore||0)){
    state.gold-=def.cost.gold; state.ore-=(def.cost.ore||0);
    if(isTower) state.towers.push(new Tower(c,r,key)); else state.buildings.push(new Building(c,r,key));
    state.buildMode=null; updateHUD();
  }else toast('‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡πÑ‡∏°‡πà‡∏û‡∏≠');
}
function loop(ts){ if(!state.lastTime) state.lastTime=ts; const dt=Math.min(0.05,(ts-state.lastTime)/1000); state.lastTime=ts; const u=dt*state.speed; update(u); draw(); requestAnimationFrame(loop); }
function update(dt){ if(state.mode!=='play') return; state.towers.forEach(t=>t.update(dt)); state.buildings.forEach(b=>b.update(dt));
  state.bullets=state.bullets.filter(b=>b.alive); state.bullets.forEach(b=>b.update(dt));
  state.enemies=state.enemies.filter(e=>e.alive); state.enemies.forEach(e=>e.update(dt));
  state.effects=state.effects.filter(e=>e.alive); state.effects.forEach(e=>e.update(dt)); updateHUD();
}
function draw(){
  drawGround(g);          // ‡∏û‡∏∑‡πâ‡∏ô‡∏´‡∏ç‡πâ‡∏≤‡πÅ‡∏ö‡∏ö texture
  drawPath(g);            // ‡∏ó‡∏≤‡∏á‡πÄ‡∏î‡∏¥‡∏ô 2 ‡∏ä‡∏±‡πâ‡∏ô + ‡πÄ‡∏á‡∏≤

  const ts = TS();

  // ‡∏ï‡∏Å‡πÅ‡∏ï‡πà‡∏á (‡πÄ‡∏î‡∏¥‡∏°)
  g.fillStyle = 'rgba(20,83,45,.45)';
  state.decorations.forEach(d=>{
    const {x,y} = tileCenter(d.c,d.r);
    g.beginPath();
    g.arc(x,y, Math.random()*6 + 6, 0, Math.PI*2);
    g.fill();
  });

  // Entities
  state.buildings.forEach(e=>e.draw(g));
  state.towers.forEach(e=>e.draw(g));
  state.enemies.forEach(e=>e.draw(g));
  state.bullets.forEach(e=>e.draw(g));
  state.effects.forEach(e=>e.draw(g));

  // Overlay ‡∏ä‡πà‡∏≠‡∏á‡∏ß‡∏≤‡∏á‡∏õ‡πâ‡∏≠‡∏° (‡∏î‡∏π‡∏Ç‡πâ‡∏≠ 2)
  drawBuildOverlay(g);
}

function updateHUD(){ const tier=CONFIG.CITADEL_TIERS[state.citadelTier];
  document.getElementById('citadelHP').textContent=state.citadelHP;
  document.getElementById('citadelMaxHP').textContent=tier.hp;
  document.getElementById('citadelTier').textContent=state.citadelTier;
  document.getElementById('gold').textContent=Math.floor(state.gold);
  document.getElementById('ore').textContent=Math.floor(state.ore);
  document.getElementById('components').textContent=Math.floor(state.components);
  document.getElementById('gears').textContent=Math.floor(state.gears);
  document.getElementById('cores').textContent=Math.floor(state.cores);
  document.getElementById('wave').textContent=state.wave;
}
function updateBuildMenu(){
  buildMenu.innerHTML=''; document.getElementById('buildTier').textContent=state.citadelTier;
  const available=[...Object.entries(CONFIG.TOWER_TYPES), ...Object.entries(CONFIG.BUILDING_TYPES)].filter(([k,d])=>d.tier<=state.citadelTier);
  for(const [key,data] of available){
    const btn=document.createElement('button'); btn.className='btn'; btn.textContent=`${data.name} (${data.cost.gold}G)`;
    btn.onclick=()=>{ if(state.buildMode===key){ state.buildMode=null; toast('‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡∏Å‡∏≤‡∏£‡∏™‡∏£‡πâ‡∏≤‡∏á'); } else { state.buildMode=key; state.selectedEntity=null; updateSelectedInfo(); } };
    buildMenu.appendChild(btn);
  }
}
function updateSelectedInfo(){
  const box = document.getElementById('selectedInfo');
  const t = state.selectedEntity;
  if(!t || t.type!=='tower'){ box.innerHTML = `<small style="color:var(--mut)">‡∏Ñ‡∏•‡∏¥‡∏Å‡∏ó‡∏µ‡πà‡∏õ‡πâ‡∏≠‡∏°‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î</small>`; return; }

  const st = t.stats, up = t.def.upgrades || {};
  const lines = [
    `<b>${t.def.name}</b> ‚Äî Lv.${t.level}`,
    `DMG: ${Math.round(st.dmg)} | RNG: ${st.range.toFixed(2)} | RATE: ${st.rate?.toFixed(2) || '-'}` +
    (st.slow? ` | SLOW: ${(st.slow*100).toFixed(0)}%` : '') +
    (st.splash? ` | SPLASH: ${st.splash.toFixed(2)}` : '')
  ];

  let btns = '';
  for(const [k,def] of Object.entries(up)){
    const costText = Object.entries(def.cost).map(([r,v])=>`${v} ${r}`).join(', ');
    btns += `<button class="btn" data-up="${k}" style="width:calc(50% - 4px)">${def.label} (${costText})</button>`;
  }

  box.innerHTML = `
    <div style="display:flex;flex-direction:column;gap:8px">
      <div>${lines.join('<br/>')}</div>
      <div style="display:flex;flex-wrap:wrap;gap:8px">${btns || '<small>‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î</small>'}</div>
    </div>
  `;

  box.querySelectorAll('button[data-up]').forEach(b=>{
    b.onclick = () => {
      const key = b.getAttribute('data-up');
      attemptUpgradeTower(t, key);
    };
  });
}

function attemptUpgradeTower(tower, key){
  const up = tower.def.upgrades?.[key]; if(!up) return;
  // ‡πÄ‡∏ä‡πá‡∏Ñ‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£
  const can = Object.entries(up.cost).every(([k,v])=> state[k] >= v);
  if(!can) return toast('‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡πÑ‡∏°‡πà‡∏û‡∏≠');

  // ‡∏ï‡∏±‡∏î‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£
  Object.entries(up.cost).forEach(([k,v])=> state[k]-=v);

  // ‡∏ú‡∏•‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î (‡∏Ñ‡∏π‡∏ì‡∏ï‡∏≤‡∏° mul)
  if(key==='dmg')   tower.stats.dmg   *= up.mul;
  if(key==='range') tower.stats.range *= up.mul;
  if(key==='rate')  tower.stats.rate  *= up.mul;
  if(key==='slow')  tower.stats.slow  *= up.mul;
  if(key==='splash')tower.stats.splash*= up.mul;

  tower.level = (tower.level||1) + 1;
  // ‡∏õ‡∏£‡∏±‡∏ö‡∏™‡∏°‡πÄ‡∏´‡∏ï‡∏∏‡∏ú‡∏•‡∏Å‡∏±‡∏ö‡πÑ‡∏ö‡πÇ‡∏≠‡∏°: ‡∏õ‡πâ‡∏≠‡∏°‡πÉ‡∏ô‡∏ó‡∏∞‡πÄ‡∏•‡∏ó‡∏£‡∏≤‡∏¢‡∏¢‡∏¥‡∏á‡∏ä‡πâ‡∏≤‡∏•‡∏á ‚Üí ‡πÉ‡∏´‡πâ rate boost ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏≠‡∏µ‡∏Å‡∏ô‡∏¥‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏°‡∏µ‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î rate
  if(key==='rate' && state.biome==='DESERT'){ tower.stats.rate *= 1.02; }

  updateHUD(); updateSelectedInfo();
  toast('‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à');
}

function updateCitadelUI(){
  const container=document.getElementById('citadelTiers'); container.innerHTML='';
  for(let i=2;i<=4;i++){ const tier=CONFIG.CITADEL_TIERS[i]; const div=document.createElement('div'); div.className='tier';
    const costHtml=Object.entries(tier.cost||{}).map(([k,v])=>`${v} ${k}`).join(', ')||'‚Äî';
    const unlocksHtml=(tier.unlocks||[]).map(k=>CONFIG.TOWER_TYPES[k]?.name||CONFIG.BUILDING_TYPES[k]?.name||k).join(', ');
    div.innerHTML=`<h4>Tier ${i}</h4><p>‡∏õ‡∏•‡∏î‡∏•‡πá‡∏≠‡∏Ñ: ${unlocksHtml}</p><button id="upgradeTier${i}" class="btn">‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î (${costHtml})</button>`;
    container.appendChild(div);
    const btn=document.getElementById(`upgradeTier${i}`);
    if(state.citadelTier>=i){ btn.textContent='‚úÖ ‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡πÅ‡∏•‡πâ‡∏ß'; btn.disabled=true; }
    else if(state.citadelTier!==i-1){ btn.textContent='‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î Tier ‡∏Å‡πà‡∏≠‡∏ô‡∏´‡∏ô‡πâ‡∏≤'; btn.disabled=true; }
    else{ btn.onclick=()=>upgradeCitadel(); }
  }
}
function upgradeCitadel(){
  const next=state.citadelTier+1; if(!CONFIG.CITADEL_TIERS[next]) return;
  const cost=CONFIG.CITADEL_TIERS[next].cost||{}; const ok=Object.entries(cost).every(([k,v])=>state[k]>=v);
  if(ok){ Object.entries(cost).forEach(([k,v])=>state[k]-=v); state.citadelTier=next; const t=CONFIG.CITADEL_TIERS[next]; state.citadelHP=t.hp; toast(`‡∏ê‡∏≤‡∏ô‡∏ó‡∏±‡∏û‡∏≠‡∏±‡∏õ‡πÄ‡∏Å‡∏£‡∏î‡πÄ‡∏õ‡πá‡∏ô Tier ${next}!`); updateHUD(); updateCitadelUI(); updateBuildMenu(); }
  else toast('‡∏ó‡∏£‡∏±‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡πÑ‡∏°‡πà‡∏û‡∏≠');
}

// ===== Events =====
document.getElementById('btnCitadel').onclick=()=>document.getElementById('citadelModal').classList.add('visible');
document.getElementById('closeCitadelModal').onclick=()=>document.getElementById('citadelModal').classList.remove('visible');
document.getElementById('btnSpeed').onclick=()=>{ state.speed=(state.speed===1?2:1); document.getElementById('btnSpeed').textContent=`‚è© Speed x${state.speed}`; };
document.getElementById('btnStart').onclick=startWave;

function setupWorldSelection(){
  const worldCanvas=document.getElementById('world'); const wCtx=worldCanvas.getContext('2d'); let pendingBiome=null;
  function drawWorldMap(){ const TW=worldCanvas.width/8, TH=worldCanvas.height/5; wCtx.clearRect(0,0,worldCanvas.width,worldCanvas.height);
    let i=0; const biomes=Object.keys(CONFIG.BIOME_MODIFIERS); const root=getComputedStyle(document.documentElement);
    for(let r=0;r<5;r++){ for(let c=0;c<8;c++){ const bk=biomes[i%biomes.length]; const bd=CONFIG.BIOME_MODIFIERS[bk]; const varName=bd.color.replace('var(','').replace(')',''); wCtx.fillStyle=root.getPropertyValue(varName).trim(); wCtx.fillRect(c*TW, r*TH, TW-2, TH-2); i++; } }
  }
  worldCanvas.onclick=e=>{ const rect=worldCanvas.getBoundingClientRect(); const x=e.clientX-rect.left, y=e.clientY-rect.top; const TW=worldCanvas.width/8, TH=worldCanvas.height/5;
    const c=Math.floor(x/TW), r=Math.floor(y/TH); const biomes=Object.keys(CONFIG.BIOME_MODIFIERS); const idx=(r*8+c)%biomes.length; pendingBiome=biomes[idx];
    const preview=document.getElementById('zonePreview'); const bd=CONFIG.BIOME_MODIFIERS[pendingBiome]; preview.innerHTML=`<b>${bd.name}:</b> ${bd.desc}`; document.getElementById('btnConfirm').disabled=false;
  };
  document.getElementById('btnConfirm').onclick=async()=>{ if(pendingBiome){ state.biome=pendingBiome; state.mode='play';
      document.getElementById('selectionContent').style.display='none'; document.getElementById('loadingOverlay').style.display='block';
      await loadAtlas('assets/atlas.png','assets/atlas.json'); // ‡πÇ‡∏´‡∏•‡∏î atlas ‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡∏û‡∏≠
      document.getElementById('worldOverlay').classList.remove('visible'); toast(`‡∏ï‡∏±‡πâ‡∏á‡∏ê‡∏≤‡∏ô‡πÉ‡∏ô ${CONFIG.BIOME_MODIFIERS[pendingBiome].name}`); initGame(); } };
  drawWorldMap();
}

// ===== Utilities =====
function resize(){ const w=document.querySelector('section').clientWidth; game.width=w; game.height=w*(CONFIG.GRID.ROWS/CONFIG.GRID.COLS); }
function buildPath(){ const raw=[{c:0,r:7},{c:1,r:7},{c:2,r:7},{c:3,r:7},{c:4,r:7},{c:5,r:6},{c:6,r:5},{c:7,r:5},{c:8,r:5},{c:9,r:5},{c:10,r:6},{c:11,r:7},{c:12,r:8},{c:13,r:8},{c:14,r:8},{c:15,r:8},{c:16,r:7},{c:17,r:6},{c:18,r:6},{c:19,r:6},{c:20,r:6},{c:21,r:7},{c:22,r:7},{c:23,r:7}];
  state.path=raw.map(p=>tileCenter(p.c,p.r)); state.pathGrid=new Set(raw.map(p=>`${p.c},${p.r}`));
}
function TS(){ return { w:game.width/CONFIG.GRID.COLS, h:game.height/CONFIG.GRID.ROWS }; }
function tileCenter(c,r){ const t=TS(); return { x:(c+0.5)*t.w, y:(r+0.5)*t.h }; }
function worldToTile(px,py){ const t=TS(); return { c:Math.floor(px/t.w), r:Math.floor(py/t.h) }; }
function dist(x1,y1,x2,y2){ return Math.hypot(x1-x2, y1-y2); }
function toast(msg){ const el=document.createElement('div'); el.style.position='fixed'; el.style.bottom='20px'; el.style.left='50%'; el.style.transform='translateX(-50%)'; el.style.background='var(--pri)'; el.style.color='#0b1220'; el.style.padding='10px 20px'; el.style.borderRadius='8px'; el.style.zIndex='200'; el.textContent=msg; document.body.appendChild(el); setTimeout(()=>el.remove(),2500); }
function nearestPathDistPx(x,y){
  let m = Infinity;
  for(const p of state.path){ const d = dist(x,y,p.x,p.y); if(d<m) m=d; }
  return m;
}
function isTooCloseToPath(c,r){
  const {x,y} = tileCenter(c,r);
  // ‡∏´‡πâ‡∏≤‡∏°‡πÉ‡∏Å‡∏•‡πâ‡∏Å‡∏∂‡πà‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏ó‡∏≤‡∏á < 0.65 tile ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏î‡∏µ (‡∏Å‡∏±‡∏ô‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏ö‡∏±‡∏á‡∏†‡∏≤‡∏û/‡∏ä‡∏ô‡∏Å‡∏±‡∏ô)
  return nearestPathDistPx(x,y) < TS().w * 0.65;
}
function drawBuildOverlay(ctx){
  if(!state.buildMode) return;
  const ts = TS();
  for(let r=0;r<CONFIG.GRID.ROWS;r++){
    for(let c=0;c<CONFIG.GRID.COLS;c++){
      const {x,y} = tileCenter(c,r);
      const onPath = state.pathGrid.has(`${c},${r}`);
      const occupied = [...state.towers, ...state.buildings].some(e=>e.c===c&&e.r===r);
      const tooClose = isTooCloseToPath(c,r);

      let alpha = .14;
      let col   = '#22c55e'; // ‡πÄ‡∏Ç‡∏µ‡∏¢‡∏ß = ‡∏ß‡∏≤‡∏á‡πÑ‡∏î‡πâ
      if (onPath || occupied || tooClose){ col = '#ef4444'; alpha = .18; }

      ctx.save();
      ctx.globalAlpha = alpha;
      ctx.fillStyle = col;
      const w = ts.w - 4, h = ts.h - 4;
      roundRect(ctx, x-w/2, y-h/2, w, h, 8); ctx.fill();
      ctx.restore();
    }
  }

  // ‡πÑ‡∏Æ‡πÑ‡∏•‡∏ï‡πå‡∏ä‡πà‡∏≠‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏°‡∏≤‡∏™‡πå‡∏ä‡∏µ‡πâ
  const t = worldToTile(state.mouse.x,state.mouse.y);
  if(t.c>=0 && t.r>=0){
    const {x,y} = tileCenter(t.c,t.r);
    ctx.save(); ctx.globalAlpha=.35; ctx.strokeStyle='#fff'; ctx.lineWidth=2;
    const w = ts.w - 2, h = ts.h - 2;
    roundRect(ctx, x-w/2, y-h/2, w, h, 10); ctx.stroke(); ctx.restore();
  }
}
function roundRect(ctx,x,y,w,h,r){
  ctx.beginPath();
  ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r);
  ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r);
  ctx.arcTo(x,y,x+w,y,r); ctx.closePath();
}

// Boot
setupWorldSelection();

})();
</script>
</body>
</html>


